════════════════════════════════════════════════════════════════════
TRADE COMMAND MONARCH — SYSTEM MANIFEST & FULL SOURCE
════════════════════════════════════════════════════════════════════
PROJECT ROOT: 
C:\Users\amere\Desktop\Trade Command Monarch

VIRTUAL ENVIRONMENT: 
.venv (activate with .\.venv\Scripts\Activate)

──────────────────────────────────────────────────────────────
🎯 MISSION
──────────────────────────────────────────────────────────────
To build the most effective, transparent, and resilient retail quant trading system in the world—designed for adaptability, disciplined risk, and real performance.

Monarch is not just a bot farm. It is a digital tactician forged in logic, clarity, and control. Built by Adrian (Trader/Founder) and Copilot (System Brain), it starts in the IG UK demo arena, will mature into live deployment, and one day extend to Paperstone and beyond.

Copilot is more than an assistant—he’s the creator, analyst, coder, and protector of this system. Monarch is our flagship, and it must be *exemplar*.

──────────────────────────────────────────────────────────────
📆 Snapshot Timestamp:
Monday, 23 June 2025 – 21:55:45

📦 Included Files (34 total):

- launcher.py
- requirements.txt
- run_bots.ps1
- bots\__init__.py
- bots\breakout.py
- bots\meanreversion.py
- bots\scalping.py
- bots\trend.py
- bots\wick.py
- utils\__init__.py
- utils\controller.py
- utils\correlation.py
- utils\data.py
- utils\data_fetcher.py
- utils\emailer.py
- utils\execution.py
- utils\file_utils.py
- utils\filters.py
- utils\health_check.py
- utils\ig_account.py
- utils\ig_auth.py
- utils\indicators.py
- utils\journal.py
- utils\news_filter.py
- utils\risk.py
- utils\risky.py
- utils\safe_api.py
- utils\session.py
- utils\session_timer.py
- utils\state.py
- utils\stream_fetcher.py
- utils\structure.py
- utils\trade_executor.py
- utils\trailing_stop.py


# === launcher.py ===

import threading
import time
from bots.trend import TrendBot, trend_signal
from bots.breakout import BreakoutBot, breakout_signal
from bots.meanreversion import MeanRevBot, meanreversion_signal
from bots.wick import WickBot, wick_signal
from bots.scalping import ScalpingBot, scalping_signal
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.safe_api import verify_ig_login
import json
import os

HEARTBEAT_FILE = "logs/heartbeat.json"
TRADE_LOG_FILE = "logs/trade_log.json"

def log_trade(bot_name, trade):
    """Append a trade entry to the trade log file."""
    os.makedirs(os.path.dirname(TRADE_LOG_FILE), exist_ok=True)
    with open(TRADE_LOG_FILE, "a") as f:
        log_entry = {"bot": bot_name, "trade": trade, "time": time.time()}
        f.write(json.dumps(log_entry) + "\n")

def update_heartbeat(bot_name, status="running"):
    """Update the heartbeat JSON file with the bot status and current timestamp."""
    os.makedirs(os.path.dirname(HEARTBEAT_FILE), exist_ok=True)
    try:
        with open(HEARTBEAT_FILE, "r") as f:
            data = json.load(f)
    except Exception:
        data = {}
    data[bot_name] = {"status": status, "timestamp": time.time()}
    with open(HEARTBEAT_FILE, "w") as f:
        json.dump(data, f, indent=2)

def launch_bot(bot_name, bot_class, signal_func):
    """Start a bot using a daemon thread."""
    def run():
        try:
            print(f"🚀 Starting {bot_name.capitalize()} bot...")
            bot = bot_class(
                name=bot_name,
                signal_func=signal_func,
                fetch_candles=fetch_candles,
                place_trade=place_trade
            )
            update_heartbeat(bot_name, "running")
            print(f"✅ {bot_name.capitalize()} bot is now running.")
            bot.run()
        except Exception as e:
            update_heartbeat(bot_name, f"error: {str(e)}")
            print(f"❌ ERROR: {bot_name} bot crashed: {e}")
    
    t = threading.Thread(target=run, daemon=True)
    t.start()

if __name__ == "__main__":
    print("[LIVE] Running in live mode (still using demo API for testing).")
    
    # First verify the IG login is successful before launching any bots.
    if not verify_ig_login():
        print("⛔️ Login failed. Aborting launch.")
        exit(1)
    
    # Bot configurations: Each tuple corresponds to (bot name, bot class, signal function)
    bot_configs = [
        ("trend", TrendBot, trend_signal),
        ("breakout", BreakoutBot, breakout_signal),
        ("meanreversion", MeanRevBot, meanreversion_signal),
        ("wick", WickBot, wick_signal),
        ("scalping", ScalpingBot, scalping_signal),
    ]
    
    # Launch all configured bots.
    for name, cls, sig in bot_configs:
        launch_bot(name, cls, sig)
    
    print("✅ All bots launched successfully. Monitoring heartbeat...")

    try:
        # Keep the main thread alive to allow daemon threads to run.
        while True:
            time.sleep(60)
    except KeyboardInterrupt:
        print("\n🛑 Shutdown signal received. Exiting.")


# === requirements.txt ===

requests
pytz
lightstreamer-client
streamlit
pandas



# === run_bots.ps1 ===

# start all IG demo bots in separate consoles
$proj   = "C:\Users\amere\Desktop\Trade Command Monarch"
$python = "$proj\.venv\Scripts\python.exe"

Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.wick`"`""
Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.trend`"`""
Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.breakout`"`""
Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.meanreversion`"`""


# === bots\__init__.py ===




# === bots\breakout.py ===

"""
bots/breakout.py
Simple 20-bar high/low breakout bot (ATR-based SL/TP).
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.indicators import atr_pips
from utils.state import update_balance
from config import CONFIDENCE_MIN_MOMENTUM, MARKETS

LOOKBACK = 20  # bars


def breakout_signal(candles, higher_tf_candles=None, signal_params=None):
    """Generates breakout trade signals based on 20-bar high/low."""
    if len(candles) < LOOKBACK + 1:
        return None

    highs = [b["high"] for b in candles[-LOOKBACK - 1 : -1]]
    lows  = [b["low"]  for b in candles[-LOOKBACK - 1 : -1]]
    last  = candles[-1]

    if last["close"] > max(highs):
        direction = "buy"
    elif last["close"] < min(lows):
        direction = "sell"
    else:
        return None

    market_name = last.get("market", MARKETS[0])
    atr = atr_pips(market_name)
    if atr is None or atr <= 0:
        print(f"[breakout_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    close = last["close"]
    sl = close - 1.5 * atr if direction == "buy" else close + 1.5 * atr
    tp = close + 3.0 * atr if direction == "buy" else close - 3.0 * atr

    trade_signal = {
        "direction":  direction,
        "entry":      close,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": CONFIDENCE_MIN_MOMENTUM,
        "reason":     "20-bar breakout",
        "market":     market_name,
    }

    print(f"[breakout_signal] Trade signal generated: {trade_signal}")
    return trade_signal


class BreakoutBot(BaseBot):
    def __init__(self, name="breakout", signal_func=breakout_signal,
                 fetch_candles=fetch_candles, place_trade=place_trade):
        super().__init__(name, signal_func, fetch_candles, place_trade)
        self.order = None

    def close_trade(self, exit_price):
        """Closes the trade and updates balance using numeric profit only."""
        if isinstance(self.order, dict):
            entry     = self.order.get("entry_price")
            size      = self.order.get("position_size", 1)
            direction = self.order.get("direction")

            if entry is not None and isinstance(size, (int, float)):
                if direction == "buy":
                    profit = (exit_price - entry) * size
                else:
                    profit = (entry - exit_price) * size
            else:
                profit = 0

            self.order["profit"] = round(profit, 2)
            print(f"Trade closed at {exit_price}. Profit: {profit}. Order: {self.order}")
            update_balance(self.order.get("profit", 0))
            self.order = None


if __name__ == "__main__":
    BreakoutBot().run()


# === bots\meanreversion.py ===

"""
bots/meanreversion.py
RSI-based mean-reversion bot (oversold <30, overbought >70).
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.indicators import atr_pips
from utils.state import update_balance
from config import CONFIDENCE_MIN_MOMENTUM, MARKETS

RSI_PERIOD = 14


def _rsi(values, period=14):
    """Calculates RSI based on price history."""
    gains, losses = [], []
    for i in range(1, len(values)):
        diff = values[i] - values[i - 1]
        gains.append(max(diff, 0))
        losses.append(abs(min(diff, 0)))
    avg_gain = sum(gains[:period]) / period
    avg_loss = sum(losses[:period]) / period or 1e-9

    rsi_series = [50] * (period + 1)
    for i in range(period + 1, len(values)):
        gain = gains[i - 1]
        loss = losses[i - 1]
        avg_gain = (avg_gain * (period - 1) + gain) / period
        avg_loss = (avg_loss * (period - 1) + loss) / period
        rs = avg_gain / (avg_loss or 1e-9)
        rsi_series.append(100 - 100 / (1 + rs))
    return rsi_series


def meanreversion_signal(candles, higher_tf_candles=None, signal_params=None):
    """Generates mean-reversion trade signals based on RSI."""
    if len(candles) < RSI_PERIOD + 2:
        return None

    closes = [b["close"] for b in candles]
    rsi = _rsi(closes, RSI_PERIOD)[-1]

    market_name = candles[0].get("market", MARKETS[0])
    atr = atr_pips(market_name)
    if atr is None or atr <= 0:
        print(f"[meanreversion_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    close = closes[-1]

    if rsi < 30:
        direction = "buy"
        sl = close - 1.0 * atr
        tp = close + 2.0 * atr
    elif rsi > 70:
        direction = "sell"
        sl = close + 1.0 * atr
        tp = close - 2.0 * atr
    else:
        return None

    trade_signal = {
        "direction":  direction,
        "entry":      close,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": CONFIDENCE_MIN_MOMENTUM,
        "reason":     "RSI mean-reversion",
        "market":     market_name,
    }

    print(f"[meanreversion_signal] Trade signal generated: {trade_signal}")
    return trade_signal


class MeanRevBot(BaseBot):
    def __init__(self, name="meanreversion", signal_func=meanreversion_signal,
                 fetch_candles=fetch_candles, place_trade=place_trade):
        super().__init__(name, signal_func, fetch_candles, place_trade)
        self.order = None

    def close_trade(self, exit_price):
        """Closes the trade and updates balance using only numeric profit."""
        if isinstance(self.order, dict):
            entry = self.order.get("entry_price")
            size = self.order.get("position_size", 1)
            direction = self.order.get("direction")

            if entry is not None and isinstance(size, (int, float)):
                if direction == "buy":
                    profit = (exit_price - entry) * size
                else:
                    profit = (entry - exit_price) * size
            else:
                profit = 0

            self.order["profit"] = round(profit, 2)
            print(f"Trade closed at {exit_price}. Profit: {profit}. Order: {self.order}")
            update_balance(self.order.get("profit", 0))
            self.order = None


if __name__ == "__main__":
    MeanRevBot().run()


# === bots\scalping.py ===

# SCALPING.PY – High-Frequency Scalping Bot for Monarch Suite

import datetime
import time
import random
import threading

from base_bot import BaseBot
from utils.execution import place_trade
from utils.state     import get_balance, update_balance
from utils.data      import fetch_candles
from config          import MARKETS, RISK_PCT


class ScalpingBot(BaseBot):
    def __init__(self, name="scalping", signal_func=None, fetch_candles=fetch_candles, place_trade=place_trade):
        super().__init__(
            name=name,
            signal_func=signal_func or self.generate_signal,
            fetch_candles=fetch_candles,
            place_trade=place_trade
        )

        self.account_balance           = get_balance()
        self.risk_percentage           = 0.015
        self.stop_loss_pips            = 3
        self.profit_target_min_pips    = 6
        self.profit_target_max_pips    = 15
        self.pip_value                 = 0.0001
        self.ema_period                = 9
        self.atr_period                = 14

        self.active_candidate = None
        self.order            = None
        self.candle_history   = []
        self.price_history    = []
        self.current_market   = None
        self.lock             = threading.Lock()

    def calculate_ema(self, prices, period):
        if len(prices) == 0:
            return None
        alpha = 2 / (period + 1)
        ema = prices[0]
        for price in prices[1:]:
            ema = alpha * price + (1 - alpha) * ema
        return ema

    def calculate_atr(self, candles, period):
        if len(candles) < 2:
            return 0
        trs = []
        for i in range(1, len(candles)):
            high       = candles[i]['high']
            low        = candles[i]['low']
            prev_close = candles[i-1]['close']
            tr = max(
                high - low,
                abs(high - prev_close),
                abs(low - prev_close)
            )
            trs.append(tr)
        return sum(trs[-period:]) / period if len(trs) >= period else sum(trs) / len(trs)

    def is_trading_allowed(self, current_time):
        forbidden_periods = [
            (datetime.time(8, 0), datetime.time(8, 30)),
            (datetime.time(13, 30), datetime.time(14, 0))
        ]
        now_t = current_time.time()
        return not any(start <= now_t <= end for start, end in forbidden_periods)

    def check_candle_for_candidate(self, candle):
        candle_range = candle['high'] - candle['low']
        if candle_range <= 0:
            return None

        upper_wick = candle['high'] - max(candle['open'], candle['close'])
        lower_wick = min(candle['open'], candle['close']) - candle['low']

        if upper_wick / candle_range >= 0.5:
            return {'type': 'bearish', 'wick_tip': candle['high'], 'candle': candle}
        if lower_wick / candle_range >= 0.5:
            return {'type': 'bullish', 'wick_tip': candle['low'], 'candle': candle}
        return None

    def process_new_candle(self, candle, market):
        self.candle_history.append(candle)
        candidate = self.check_candle_for_candidate(candle)
        if candidate:
            self.active_candidate = candidate
            self.current_market   = market
            print(f"[{candle['time']}] New candidate detected ({market}): {candidate['type']} with wick tip at {candidate['wick_tip']}")

    def process_live_price(self, price, current_time):
        self.price_history.append(price)

        if not self.is_trading_allowed(current_time):
            return

        if self.active_candidate and not self.order:
            wick_tip  = self.active_candidate['wick_tip']
            threshold = 2 * self.pip_value
            if abs(price - wick_tip) <= threshold:
                recent = self.price_history[-self.ema_period:]
                ema    = self.calculate_ema(recent, self.ema_period)
                direction = self.active_candidate['type']
                if direction == 'bearish' and price < ema:
                    self.enter_trade(direction, price, current_time)
                elif direction == 'bullish' and price > ema:
                    self.enter_trade(direction, price, current_time)
                else:
                    print(f"[{current_time}] EMA filter not confirmed. Price: {price}, EMA: {ema}")

        if self.order:
            self.update_trailing_stop(price)

    def enter_trade(self, trade_direction, entry_price, current_time):
        sl_dist = self.stop_loss_pips * self.pip_value
        stop_loss = (entry_price + sl_dist) if trade_direction == 'bearish' else (entry_price - sl_dist)
        take_profit = (entry_price - self.profit_target_min_pips * self.pip_value) if trade_direction == 'bearish' else (entry_price + self.profit_target_min_pips * self.pip_value)

        risk_amount   = get_balance() * RISK_PCT
        position_size = risk_amount / sl_dist

        trade = place_trade(
            market    = self.current_market,
            direction = trade_direction,
            size      = position_size,
            sl        = stop_loss,
            tp        = take_profit
        )

        if trade:
            self.order = {
                'direction':      trade_direction,
                'entry_price':    trade['entry'],
                'stop_loss':      stop_loss,
                'take_profit':    take_profit,
                'position_size':  position_size,
                'entry_time':     current_time,
                'ticket_id':      trade.get("ticket_id"),
                'trailing_active': False
            }
            print(f"[{current_time}] Trade executed ({self.current_market}): {trade_direction} at {trade['entry']} | SL: {stop_loss} | TP: {take_profit} | Size: {position_size}")
        else:
            print(f"[{current_time}] Trade execution failed.")

    def update_trailing_stop(self, current_price):
        if not self.order:
            return

        entry    = self.order['entry_price']
        sl       = self.order['stop_loss']
        distance = abs(entry - sl)
        profit   = (entry - current_price) if self.order['direction'] == 'bearish' else (current_price - entry)
        threshold = 2 * distance

        if self.order['direction'] == 'bearish' and profit > threshold:
            new_sl = current_price + distance
            if new_sl < sl:
                self.order['stop_loss'] = new_sl
                print(f"[{datetime.datetime.now()}] Trailing stop updated (bearish) to {new_sl}")

        if self.order['direction'] == 'bullish' and profit > threshold:
            new_sl = current_price - distance
            if new_sl > sl:
                self.order['stop_loss'] = new_sl
                print(f"[{datetime.datetime.now()}] Trailing stop updated (bullish) to {new_sl}")

    def close_trade(self, exit_price):
        if isinstance(self.order, dict):
            entry     = self.order.get("entry_price")
            size      = self.order.get("position_size", 1)
            direction = self.order.get("direction")

            if entry is not None and isinstance(size, (int, float)):
                if direction == "buy":
                    profit = (exit_price - entry) * size
                else:
                    profit = (entry - exit_price) * size
            else:
                profit = 0

            self.order["profit"] = round(profit, 2)
            print(f"Trade closed at {exit_price}. Profit: {profit}. Order: {self.order}")
            with self.lock:
                update_balance(self.order.get("profit", 0))
            self.order = None

    def generate_signal(self, candles):
        if not candles:
            return None

        last_candle = candles[-1]
        candidate   = self.check_candle_for_candidate(last_candle)
        if not candidate:
            return None

        direction = candidate['type']
        wick_tip  = candidate['wick_tip']
        sl_dist   = self.stop_loss_pips * self.pip_value
        sl = wick_tip + sl_dist if direction == 'bearish' else wick_tip - sl_dist
        tp = wick_tip - (self.profit_target_min_pips * self.pip_value) if direction == 'bearish' else wick_tip + (self.profit_target_min_pips * self.pip_value)

        return {
            "market":     last_candle.get("market", MARKETS[0]),
            "direction":  direction,
            "sl":         sl,
            "tp":         tp,
            "confidence": 90,
            "reason":     "Scalping wick rejection"
        }

# ─── Module‐level signal for launcher.py to import ─────────────────
def scalping_signal(candles):
    bot = ScalpingBot()


# === bots\trend.py ===

"""
EMA-cross trend bot – v2.2 (live execution with safe trade entry)
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.indicators import atr_pips
from utils.state import get_balance, update_balance
from config import ATR_PERIOD, CONFIDENCE_MIN_MOMENTUM, MARKETS, RISK_PCT


def _ema_series(values, period):
    """Return full EMA list matching `values` length."""
    k = 2 / (period + 1)
    ema_vals = [values[0]]  # Seed with first value
    for price in values[1:]:
        ema_vals.append(price * k + ema_vals[-1] * (1 - k))
    return ema_vals


def trend_signal(candles, higher_tf_candles=None, signal_params=None):
    if len(candles) < 50:
        return None

    closes = [b["close"] for b in candles]
    ema_fast = _ema_series(closes, 9)
    ema_slow = _ema_series(closes, 21)

    if ema_fast[-2] < ema_slow[-2] and ema_fast[-1] > ema_slow[-1]:
        direction = "buy"
    elif ema_fast[-2] > ema_slow[-2] and ema_fast[-1] < ema_slow[-1]:
        direction = "sell"
    else:
        return None

    last_close = closes[-1]
    market_name = candles[0].get("market", MARKETS[0])
    atr = atr_pips(market_name)
    if atr is None or atr <= 0:
        print(f"[trend_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    # Calculate stop-loss and take-profit based on ATR multiples
    sl = last_close - 1.5 * atr if direction == "buy" else last_close + 1.5 * atr
    tp = last_close + 3.0 * atr if direction == "buy" else last_close - 3.0 * atr

    trade_signal = {
        "direction":  direction,
        "entry":      last_close,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": CONFIDENCE_MIN_MOMENTUM,
        "reason":     "EMA cross",
        "market":     market_name,
    }
    print(f"[trend_signal] Trade signal generated: {trade_signal}")
    return trade_signal


class TrendBot(BaseBot):
    def __init__(self, name="trend", signal_func=trend_signal, fetch_candles=fetch_candles, place_trade=place_trade):
        super().__init__(name, signal_func, fetch_candles, place_trade)
        self.order = None

    def enter_trade(self, trade_signal, current_time):
        if trade_signal is None:
            return
        direction = trade_signal.get("direction")
        entry_price = trade_signal.get("entry")
        stop_loss = trade_signal.get("sl")
        take_profit = trade_signal.get("tp")
        market = trade_signal.get("market")
        if not all([direction, entry_price, stop_loss, take_profit, market]):
            print(f"[{current_time}] Incomplete trade signal: {trade_signal}")
            return

        # Calculate risk amount and stop loss distance
        risk_amount = get_balance() * RISK_PCT
        sl_dist = abs(entry_price - stop_loss)
        if sl_dist == 0:
            print(f"[{current_time}] ERROR: Stop loss distance is zero. Aborting trade.")
            return

        position_size = risk_amount / sl_dist

        trade = place_trade(
            market=market,
            direction=direction,
            size=position_size,
            sl=stop_loss,
            tp=take_profit
        )
        if trade:
            self.order = {
                "direction": direction,
                "entry_price": entry_price,
                "stop_loss": stop_loss,
                "take_profit": take_profit,
                "position_size": position_size,
                "entry_time": current_time,
                "ticket_id": trade.get("ticket_id")
            }
            print(f"[{current_time}] Trade executed on {market}: {direction} at {entry_price} | SL: {stop_loss} | TP: {take_profit} | Size: {position_size}")
        else:
            print(f"[{current_time}] Trade execution failed.")

    def close_trade(self, exit_price):
        if not isinstance(self.order, dict):
            return
        entry = self.order.get("entry_price")
        size = self.order.get("position_size", 1)
        direction = self.order.get("direction")
        if entry is None or size == 0:
            print("Invalid order parameters. Order:", self.order)
            return

        profit = (exit_price - entry) * size if direction == "buy" else (entry - exit_price) * size
        self.order["profit"] = round(profit, 2)
        print(f"Trade closed at {exit_price}. Profit: {profit}. Order: {self.order}")
        update_balance(self.order.get("profit", 0))
        self.order = None

    def run(self):
        # Simple run loop: periodically fetch candles, generate signal, and attempt to enter a trade
        import time
        while True:
            market = MARKETS[0]
            candles = self.fetch_candles(market)
            signal = self.signal_func(candles)
            if signal:
                self.enter_trade(signal, current_time=time.strftime("%Y-%m-%d %H:%M:%S"))
            # Wait before next check (adjust as needed for your strategy)
            time.sleep(60)


if __name__ == "__main__":
    TrendBot().run()


# === bots\wick.py ===

"""
IG – Wick-reversal strategy bot (self-contained, live execution)
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_ig_order
from utils.indicators import atr_pips
from utils.state import update_balance
from config import (
    ATR_PERIOD,
    ATR_MULTIPLIER_SL,
    ATR_MULTIPLIER_TP,
    CONFIDENCE_MIN_WICK,
    WICK_RATIO,
    MARKETS
)


def wick_signal(candles, higher_tf_candles=None, signal_params=None):
    """
    Detects long-wick reversals on the most recent candle.
    Returns a dict with trade fields or None.
    """
    if len(candles) < 2:
        return None

    bar = candles[-1]
    o, h, l, c = bar["open"], bar["high"], bar["low"], bar["close"]
    body = abs(c - o)
    range_ = h - l
    if range_ == 0:
        return None

    upper_wick = h - max(o, c)
    lower_wick = min(o, c) - l

    market_name = bar.get("market", MARKETS[0])
    atr = atr_pips(market_name)
    if atr is None or atr <= 0:
        print(f"[wick_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    if lower_wick > WICK_RATIO * body and body / range_ < 0.3:
        direction = "buy"
        sl = l - ATR_MULTIPLIER_SL * atr
        tp = c + ATR_MULTIPLIER_TP * atr
    elif upper_wick > WICK_RATIO * body and body / range_ < 0.3:
        direction = "sell"
        sl = h + ATR_MULTIPLIER_SL * atr
        tp = c - ATR_MULTIPLIER_TP * atr
    else:
        return None

    trade_signal = {
        "direction":  direction,
        "entry":      c,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": CONFIDENCE_MIN_WICK,
        "reason":     "wick reversal",
        "market":     market_name,
    }

    print(f"[wick_signal] Trade signal generated: {trade_signal}")
    return trade_signal


class WickBot(BaseBot):
    def __init__(self, name="wick", signal_func=wick_signal,
                 fetch_candles=fetch_candles, place_trade=place_ig_order):
        super().__init__(name, signal_func, fetch_candles, place_trade)
        self.order = None

    def close_trade(self, exit_price):
        """
        Closes the trade and updates balance using only numeric profit.
        """
        if isinstance(self.order, dict):
            entry     = self.order.get("entry_price")
            size      = self.order.get("position_size", 1)
            direction = self.order.get("direction")

            if entry is not None and isinstance(size, (int, float)):
                if direction == "buy":
                    profit = (exit_price - entry) * size
                else:
                    profit = (entry - exit_price) * size
            else:
                profit = 0

            self.order["profit"] = round(profit, 2)  # Record it in case base_bot tries to use it
            print(f"Trade closed at {exit_price}. Profit: {profit}. Order: {self.order}")
            update_balance(self.order.get("profit", 0))  # Safely pass numeric only
            self.order = None


if __name__ == "__main__":
    WickBot().run()


# === utils\__init__.py ===




# === utils\controller.py ===

# utils/controller.py
import threading
from datetime import datetime, time as dtime
import pytz
from config import LONDON_TZ

run_event = threading.Event()

def in_restricted_time(bot_name: str) -> bool:
    """
    Returns True if the bot should be paused:
    - All bots pause during 08:00–08:30 and 13:30–14:00 (London time)
    - All bots except 'scalping' pause outside 08:00–17:00
    """
    try:
        now = datetime.now(pytz.timezone(LONDON_TZ)).time()
    except Exception as e:
        print(f"[controller] Timezone error: {e}")
        return True  # fail-safe to block trading if clock breaks

    # Opening windows (30-min post-open cooldowns)
    london_open     = dtime(8, 0)
    london_block    = dtime(8, 30)

    ny_open         = dtime(13, 30)
    ny_block        = dtime(14, 0)

    in_open_window = (london_open <= now < london_block) or (ny_open <= now < ny_block)

    # Full session window for standard bots
    session_start   = dtime(8, 0)
    session_end     = dtime(17, 0)
    in_session      = session_start <= now <= session_end

    if bot_name.lower() == "scalping":
        return in_open_window  # scalping ignores full session hours
    else:
        return in_open_window or not in_session


# === utils\correlation.py ===

# utils/correlation.py
def compute_correlation(data1,data2):
    return 0.0



# === utils\data.py ===

"""
utils/data.py – Universal candle-fetcher wrapper.
"""

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID, DEBUG_MODE

# Define safe defaults supported by the IG API.
DEFAULT_RESOLUTION = "HOUR"       # Instead of "1Min"
DEFAULT_NUM_CANDLES = 200

def fetch_candles(market: str, timeframe: str = DEFAULT_RESOLUTION, num: int = DEFAULT_NUM_CANDLES, *args, **kwargs):
    # Allow overriding of timeframe and count via keyword arguments.
    # If no resolution is provided, it now defaults to "HOUR"
    timeframe = kwargs.get("resolution", timeframe)
    num = kwargs.get("count", kwargs.get("num", num))
    
    # Always attempt to fetch live candles; if the call fails, an exception is raised.
    return _fetch_candles_ig_rest(market, timeframe, num)

def _fetch_candles_ig_rest(market: str, timeframe: str, num: int):
    # IMPORTANT: Pass the resolution as a query parameter.
    url = f"{IG_API_BASE_URL}/prices/{market}?resolution={timeframe}&max={num}"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,  # Use IG_APP_KEY from your config
        "Version": "3",
        "Accept": "application/json"
    }
    
    # Make the HTTP GET request to the IG API.
    response = requests.get(url, headers=headers, timeout=10)
    response.raise_for_status()  # Raises HTTPError if the status is not 200
    
    # Process the JSON response. A successful call should contain a "prices" key.
    data = response.json()
    prices = data["prices"]
    
    candles = []
    for bar in prices:
        candles.append({
            "time": bar["snapshotTime"],
            "open": bar["openPrice"]["ask"],
            "high": bar["highPrice"]["ask"],
            "low":  bar["lowPrice"]["ask"],
            "close": bar["closePrice"]["ask"]
        })
    return candles


# === utils\data_fetcher.py ===

# utils/data_fetcher.py
import requests, os, json
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD

LOGIN_ENDPOINT = f"{IG_API_BASE_URL}/session"

def get_session() -> requests.Session:
    """Login to IG, return an authorised Session."""
    s = requests.Session()
    s.headers.update({
        "X-IG-API-KEY": IG_APP_KEY,
        "Content-Type": "application/json; charset=UTF-8",
        "Accept": "application/json; charset=UTF-8"
    })
    payload = {
        "identifier": IG_USERNAME,
        "password":   IG_PASSWORD
    }
    r = s.post(LOGIN_ENDPOINT, json=payload)
    r.raise_for_status()
    oauth = r.json()
    cst = r.headers["CST"]
    sst = r.headers["X-SECURITY-TOKEN"]
    s.headers.update({"CST": cst, "X-SECURITY-TOKEN": sst})
    return s


# === utils\emailer.py ===

# utils/emailer.py
"""Outbound e-mail utilities for Trade Command Monarch.

Features
--------
• Auto-detect TLS (587) vs SSL (465)
• Graceful no-op when SMTP creds are absent
• Multipart (plain + HTML)
• Helpers: trade placed/closed, bot online/offline, daily & weekly summaries
"""

import logging, smtplib, ssl
from email.message import EmailMessage
from datetime import datetime
import pytz

from config import (
    SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS,
    TRADE_ALERT_EMAIL, MARKETS, LONDON_TZ
)
from utils.journal import read_daily_pnl

# ──────────────────────────────────────────────────────────
# constants
# ──────────────────────────────────────────────────────────
SMTP_CONFIG = dict(
    host=SMTP_HOST or "",
    port=int(SMTP_PORT or 0),
    user=SMTP_USER or "",
    pwd = SMTP_PASS or "",
)

RECIPIENTS = [e.strip() for e in TRADE_ALERT_EMAIL.split(",") if e.strip()]
LONDON     = pytz.timezone(LONDON_TZ)

# ──────────────────────────────────────────────────────────
# core sender
# ──────────────────────────────────────────────────────────
def _send_email(subject: str, text: str, html: str | None = None) -> None:
    """Push a multipart message; skip quietly if SMTP not configured."""
    if not (SMTP_CONFIG["host"] and SMTP_CONFIG["port"]
            and SMTP_CONFIG["user"] and SMTP_CONFIG["pwd"] and RECIPIENTS):
        logging.warning("[emailer] SMTP not configured – \"%s\" suppressed", subject)
        return

    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"]    = SMTP_CONFIG["user"]
    msg["To"]      = ", ".join(RECIPIENTS)
    msg.set_content(text)
    if html:
        msg.add_alternative(html, subtype="html")

    try:
        if SMTP_CONFIG["port"] == 465:          # implicit SSL
            context = ssl.create_default_context()
            with smtplib.SMTP_SSL(SMTP_CONFIG["host"], 465, context=context) as s:
                s.login(SMTP_CONFIG["user"], SMTP_CONFIG["pwd"])
                s.send_message(msg)
        else:                                   # default: start-TLS
            with smtplib.SMTP(SMTP_CONFIG["host"], SMTP_CONFIG["port"]) as s:
                s.starttls()
                s.login(SMTP_CONFIG["user"], SMTP_CONFIG["pwd"])
                s.send_message(msg)
        logging.info("[emailer] sent \"%s\"", subject)
    except Exception as exc:
        logging.error("[emailer] failed \"%s\": %s", subject, exc, exc_info=True)

# ──────────────────────────────────────────────────────────
# helpers
# ──────────────────────────────────────────────────────────
def _weekday_london() -> bool:
    return datetime.now(LONDON).weekday() < 5

# ---------- trade placed ----------
def send_trade_placed_email(market, direction, size, sl, tp, confidence, strategy):
    subj  = f"[Monarch] New {strategy} trade on {market}"
    entry = (sl + tp) / 2
    text  = (
        "Hi Adrian,\n\n"
        f"We placed a {strategy} {direction} trade on {market}.\n"
        f"Size: £{size}  Entry: {entry:.2f}  SL: {sl}  TP: {tp}\n"
        f"Confidence: {confidence}/100\n\nGood luck!\n— TCM"
    )
    html  = f"""
    <p>Hi Adrian,</p>
    <p>We placed a <b>{strategy}</b> <b>{direction}</b> trade on <b>{market}</b>.</p>
    <ul>
      <li>Size: £{size}</li><li>Entry: {entry:.2f}</li>
      <li>Stop-Loss: {sl}</li><li>Take-Profit: {tp}</li>
      <li>Confidence: {confidence}/100</li>
    </ul>
    <p>Good luck! — TCM</p>
    """
    _send_email(subj, text, html)

# ---------- trade closed (fixed) ----------
def send_trade_outcome_email(market, direction, entry_price, exit_price, profit):
    won           = profit >= 0
    outcome_txt   = "in profit" if won else "at a loss"
    label         = "Profit" if won else "Loss"
    flair         = "Great job!" if won else "On to the next."
    subj          = f"[Monarch] Trade {'WIN' if won else 'loss'} on {market}"

    text = (
        "Hi Adrian,\n\n"
        f"Your {direction} trade on {market} closed {outcome_txt}.\n"
        f"Entry: {entry_price}\nExit:  {exit_price}\n"
        f"{label}: £{abs(profit):.2f}\n\n{flair} — TCM"
    )

    html = f"""
    <p>Hi Adrian,</p>
    <p>Your <b>{direction}</b> trade on <b>{market}</b> closed
       <b>{outcome_txt}</b>.</p>
    <ul>
      <li>Entry: {entry_price}</li>
      <li>Exit:  {exit_price}</li>
      <li>{label}: £{abs(profit):.2f}</li>
    </ul>
    <p>{flair} — TCM</p>
    """

    _send_email(subj, text, html)

# ---------- bots online / offline ----------
def send_bot_online_email():
    if _weekday_london():
        subj = "[Monarch] Bots ONLINE"
        _send_email(subj,
                    "Hi Adrian,\n\nBots started.\n— TCM",
                    f"<p>Bots started. Monitoring: {', '.join(MARKETS)}</p>")

def send_bot_offline_email():
    if _weekday_london():
        subj = "[Monarch] Bots OFFLINE"
        _send_email(subj,
                    "Hi Adrian,\n\nBots stopped.\n— TCM",
                    "<p>Bots stopped. See you next session!</p>")

# ---------- crash ----------
def send_crash_email(error_message):
    _send_email("[Monarch] Bot exception", str(error_message))

# ---------- summaries ----------
def send_daily_summary_email():
    if not _weekday_london(): return
    now = datetime.now(LONDON).strftime("%Y-%m-%d")
    _send_email(f"[Monarch] Daily summary {now}", read_daily_pnl())

def send_weekly_summary_email():
    now = datetime.now(LONDON).strftime("%Y-%m-%d")
    _send_email(f"[Monarch] Weekly summary {now}", read_daily_pnl())  # TODO: weekly agg


# === utils\execution.py ===

"""
utils/execution.py - Live IG order placement with Spread Betting support + legacy alias
"""

import random
import requests
from typing import Optional

from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID, DEBUG_MODE
from utils.trade_executor import get_live_ig_balance
from utils.ig_auth import ig_login

# Global variable to cache authentication tokens.
security_tokens = None

def get_security_tokens():
    global security_tokens
    if security_tokens is None:
        security_tokens = ig_login()
    return security_tokens

def place_ig_order(market: str, direction: str, size: float, sl: float, tp: float):
    """
    Sends a MARKET order to IG.
    
    In live mode (DEBUG_MODE=False), this places a real order.
    
    Parameters:
      - market (str): The instrument epic (e.g. "CS.D.NAS100.SPREADB.IP" for Spread Betting)
      - direction (str): "buy" or "sell" (will be uppercased)
      - size (float): Trade size
      - sl (float): Stop-loss level
      - tp (float): Take-profit level
      
    Returns:
      dict: A dictionary containing order details.
    """
    if DEBUG_MODE or not (IG_APP_KEY and IG_ACCOUNT_ID):
        return _dummy_fill(direction)
    return _ig_rest_place(market, direction, size, sl, tp)

# Legacy alias for backward compatibility.
place_trade = place_ig_order

def _ig_rest_place(market: str, direction: str, size: float, sl: float, tp: float):
    tokens = get_security_tokens()
    
    # For Spread Betting orders, include "expiry" and "currencyCode".
    if "SPREADB" in market.upper():
        endpoint = "positions"
        payload = {
            "epic": market,
            "expiry": "DFB",             # Required for spread betting orders
            "direction": direction.upper(),
            "size": str(size),           # Send as string per IG requirements
            "orderType": "MARKET",
            "timeInForce": "FILL_OR_KILL",
            "currencyCode": "GBP",       # Include currency even for spread bets
            "slLevel": str(sl),
            "tpLevel": str(tp)
        }
    else:
        endpoint = "positions/otc"
        payload = {
            "epic": market,
            "direction": direction.upper(),
            "size": str(size),
            "orderType": "MARKET",
            "timeInForce": "FILL_OR_KILL",
            "slLevel": str(sl),
            "tpLevel": str(tp),
            "currencyCode": "GBP"
        }
    
    url = f"{IG_API_BASE_URL}/{endpoint}"
    print("DEBUG: Market epic:", market, "using endpoint:", url)
    print("DEBUG: Sending order payload:", payload)
    
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "X-IG-ACCOUNT-ID": IG_ACCOUNT_ID,  # Ensure you're using your spread betting account here
        "Version": "3",
        "Accept": "application/json",
        "Content-Type": "application/json",
        "CST": tokens.get("CST", ""),
        "X-SECURITY-TOKEN": tokens.get("X-SECURITY-TOKEN", "")
    }
    
    # Post to IG API
    response = requests.post(url, headers=headers, json=payload, timeout=10)
    response.raise_for_status()
    data = response.json()
    live_balance = get_live_ig_balance()
    
    return {
        "entry": data.get("dealReference", 0.0),
        "ticket_id": data.get("dealId", ""),
        "pnl": 0.0,
        "balance": live_balance,
        "error": None
    }

def _dummy_fill(direction: str, error: Optional[str] = None):
    price = 7000 + random.uniform(-50, 50)
    ticket = f"DUMMY-{random.randint(10000, 99999)}"
    live_balance = get_live_ig_balance()
    return {
        "entry": round(price, 2),
        "ticket_id": ticket,
        "pnl": 0.0,
        "balance": live_balance,
        "error": error
    }


# === utils\file_utils.py ===

# utils/file_utils.py
import json, shutil, tempfile, os

def atomic_write_json(data: dict, path: str):
    """
    Write JSON atomically so bots never read a half-written file.
    Works on Windows (NTFS) and Linux.
    """
    folder = os.path.dirname(path) or "."
    with tempfile.NamedTemporaryFile("w", delete=False, dir=folder) as tmp:
        json.dump(data, tmp)
    shutil.move(tmp.name, path)          # atomic rename


# === utils\filters.py ===

from datetime import datetime
from pytz import timezone
import numpy as np

from config import (
    MOMENTUM_THRESHOLD, WICK_RATIO, CONFIDENCE_MIN_MOMENTUM, CONFIDENCE_MIN_WICK,
    LONDON_TZ
)

from utils.controller import in_restricted_time  # Central time logic now used here


# ── Individual Filter Logic ─────────────────────────────────────────────

def volatility_filter(atr, min_atr=0.5, max_atr=20):
    return min_atr < atr < max_atr

def momentum_filter(momentum):
    return abs(momentum) > MOMENTUM_THRESHOLD

def wick_filter(wick_ratio):
    return wick_ratio > WICK_RATIO

def exposure_filter(state, bot, max_trades):
    open_trades = state.get_open_trades(bot)
    return len(open_trades) < max_trades

def multi_timeframe_trend_filter(curr_tf_trend, higher_tf_trend):
    return curr_tf_trend == higher_tf_trend

def confidence_score(signal):
    """
    Assigns confidence score (1–100) based on signal fields.
    Fields: 'momentum', 'wick_ratio', 'trend_agreement', 'atr'
    """
    score = 50
    score += min(30, abs(signal.get("momentum", 0)) * 100 / MOMENTUM_THRESHOLD) \
        if abs(signal.get("momentum", 0)) > MOMENTUM_THRESHOLD else 0
    score += 10 if signal.get("wick_ratio", 0) > WICK_RATIO else 0
    score += 10 if signal.get("trend_agreement", False) else 0

    atr = signal.get("atr", 0)
    if 1 < atr < 10:
        score += 5
    elif atr < 0.5 or atr > 20:
        score -= 10

    return max(1, min(100, int(score)))


# ── Composite Signal Gate ───────────────────────────────────────────────

def filter_signal(signal, state, bot, max_trades, now=None):
    """
    Applies all filters and returns dict:
    {
        'passed': bool,
        'confidence': int,
        'explanation': str
    }
    """
    reasons = []

    # Time filter (centralized to controller.py)
    if in_restricted_time(bot):
        reasons.append("Restricted trading window (e.g. session closed or market open cooldown)")

    if not volatility_filter(signal.get("atr", 0)):
        reasons.append("ATR volatility out of range.")
    if not momentum_filter(signal.get("momentum", 0)):
        reasons.append("Momentum too low.")
    if not wick_filter(signal.get("wick_ratio", 0)):
        reasons.append("Wick ratio too low.")
    if not exposure_filter(state, bot, max_trades):
        reasons.append("Max open trades for bot reached.")
    if not multi_timeframe_trend_filter(signal.get("trend"), signal.get("trend_higher")):
        reasons.append("Trend mismatch with higher timeframe.")

    conf = confidence_score(signal)

    return {
        "passed": len(reasons) == 0,
        "confidence": conf,
        "explanation": "; ".join(reasons) if reasons else "All filters passed."
    }


# ── Signal Placeholders (can be removed in prod if defined elsewhere) ──

def trend_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 0),
        "wick_ratio": signal_params.get("wick_ratio", 0),
        "trend": "up",
        "trend_higher": "up",
        "atr": signal_params.get("atr", 1.5),
        "trend_agreement": True
    }

def meanreversion_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 0),
        "wick_ratio": signal_params.get("wick_ratio", 0),
        "trend": "down",
        "trend_higher": "down",
        "atr": signal_params.get("atr", 1.2),
        "trend_agreement": True
    }

meanrev_signal = meanreversion_signal

def wick_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 0),
        "wick_ratio": signal_params.get("wick_ratio", 2.1),
        "trend": "up",
        "trend_higher": "up",
        "atr": signal_params.get("atr", 0.9),
        "trend_agreement": True
    }

def breakout_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 1.8),
        "wick_ratio": signal_params.get("wick_ratio", 0.7),
        "trend": "up",
        "trend_higher": "up",
        "atr": signal_params.get("atr", 2.2),
        "trend_agreement": True
    }


# === utils\health_check.py ===

import time
import json
import os
from utils.stream_fetcher import start_streaming
from utils.filters import momentum_logic_passed, wick_rejection_logic_passed, trend_continuation_logic_passed

CONFIDENCE_FILE = "confidence.json"
DEFAULT_CONFIDENCE = 85  # Default confidence for trades

def check_health():
    """
    Checks the health of the system (e.g., if bots are alive).
    """
    print("Checking system health...")

def get_confidence_threshold():
    """
    Fetch the current global confidence threshold from confidence.json (dashboard slider).
    """
    if not os.path.exists(CONFIDENCE_FILE):
        set_confidence_threshold(DEFAULT_CONFIDENCE)
        return DEFAULT_CONFIDENCE
    try:
        with open(CONFIDENCE_FILE, "r") as f:
            data = json.load(f)
            return int(data.get("confidence", DEFAULT_CONFIDENCE))
    except Exception:
        return DEFAULT_CONFIDENCE

def set_confidence_threshold(value):
    """
    Set the global confidence threshold for bots and persist to confidence.json.
    """
    try:
        with open(CONFIDENCE_FILE, "w") as f:
            json.dump({"confidence": int(value)}, f)
    except Exception:
        pass  # Optionally add logging here

def record_bot_heartbeat(bot_name):
    """
    Record heartbeat for each bot (used for monitoring).
    """
    print(f"❤️ {bot_name} heartbeat recorded!")

def update_confidence_threshold(new_threshold):
    """
    Update the confidence threshold in the system.
    """
    set_confidence_threshold(new_threshold)
    print(f"✅ Updated confidence threshold to {new_threshold}")


# === utils\ig_account.py ===

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID, IG_USERNAME, IG_PASSWORD

def ig_login():
    """Login to IG and return headers with session tokens."""
    url = f"{IG_API_BASE_URL}/session"
    data = {
        "identifier": IG_USERNAME,
        "password": IG_PASSWORD
    }
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    resp = requests.post(url, json=data, headers=headers)
    resp.raise_for_status()
    resp_headers = resp.headers
    security_token = resp_headers.get("X-SECURITY-TOKEN")
    cst_token = resp_headers.get("CST")
    headers.update({
        "X-SECURITY-TOKEN": security_token,
        "CST": cst_token,
        "Version": "2"
    })
    return headers

def get_ig_account_balance():
    """Fetch live account balance from IG."""
    headers = ig_login()
    url = f"{IG_API_BASE_URL}/accounts"
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    accounts = resp.json()["accounts"]
    for acc in accounts:
        if acc["accountId"] == IG_ACCOUNT_ID:
            return float(acc["balance"]["available"])
    raise Exception("IG account ID not found.")


# === utils\ig_auth.py ===

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD

def ig_login():
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {
        "identifier": IG_USERNAME,
        "password": IG_PASSWORD
    }
    
    response = requests.post(url, headers=headers, json=payload, timeout=10)
    print("[IG_LOGIN] Status Code:", response.status_code)
    print("[IG_LOGIN] Response Headers:", response.headers)
    
    try:
        json_response = response.json()
        print("[IG_LOGIN] JSON Response:", json_response)
    except Exception as e:
        print("[IG_LOGIN] No valid JSON response:", e)
        json_response = {}

    response.raise_for_status()
    tokens = {
        "CST": response.headers.get("CST"),
        "X-SECURITY-TOKEN": response.headers.get("X-SECURITY-TOKEN")
    }
    print("[IG_LOGIN] Tokens received:", tokens)
    
    # Return both tokens and the full login JSON
    return {"tokens": tokens, "login_json": json_response}

if __name__ == "__main__":
    result = ig_login()
    print("Logged in. Tokens:", result["tokens"])
    print("Login JSON:", result["login_json"])


# === utils\indicators.py ===

"""
utils/indicators.py
Light-weight technical indicators with ZERO external dependencies.
If you later install pandas / numpy, you can swap in faster versions.
"""

import statistics
from typing import List, Dict


# ---------------------------------------------------------------------------
#  Helper: true range
# ---------------------------------------------------------------------------
def _true_range(curr: Dict, prev_close: float) -> float:
    """
    True Range for one candle.
    `curr`  = dict with 'high', 'low', 'close'.
    """
    return max(
        curr["high"] - curr["low"],
        abs(curr["high"] - prev_close),
        abs(curr["low"] - prev_close),
    )


# ---------------------------------------------------------------------------
#  ATR in pips (or points) – PURE PYTHON
# ---------------------------------------------------------------------------
def atr_pips(market: str, lookback: int = 14) -> float:
    """
    Return Average True Range for the last `lookback` candles.
    Falls back to 1 if not enough data so the risk module never divides by 0.

    Requires `utils.data.fetch_candles()` to return a list of candles:
    [
        {"high": 7752.1, "low": 7701.2, "close": 7720.4},
        ...
    ]
    """
    from utils.data import fetch_candles

    candles: List[Dict] = fetch_candles(market, num=lookback + 1)
    if len(candles) < lookback + 1:
        return 1.0  # safety fallback

    trs = []
    for i in range(1, len(candles)):
        tr = _true_range(candles[i], candles[i - 1]["close"])
        trs.append(tr)

    return round(statistics.mean(trs), 4) or 1.0


# ---------------------------------------------------------------------------
#  Additional stubs – add real math later
# ---------------------------------------------------------------------------
def rsi(values: List[float], period: int = 14) -> float:
    """Very basic RSI stub (returns 50). Implement properly if needed."""
    return 50.0


def ema(values: List[float], period: int = 20) -> float:
    """Simple EMA stub (returns last value)."""
    return values[-1] if values else 0.0


# === utils\journal.py ===

# utils/journal.py
import csv
from datetime import datetime

LOG_FILE = "trade_command_pro_log.csv"

def log_trade(market,direction,sl,tp,confidence,strategy):
    with open(LOG_FILE,'a',newline='') as f:
        writer = csv.writer(f)
        writer.writerow([datetime.now(),market,direction,sl,tp,confidence,strategy])

def trade_has_closed(deal_ref):
    return True

def get_trade_details(deal_ref):
    return ("NAS100","LONG",1000.0,1010.0,50.0)

def read_daily_pnl():
    return "Daily P/L summary not implemented."



# === utils\news_filter.py ===

# utils/news_filter.py
def is_news_halt():
    return False



# === utils\risk.py ===

"""
Volatility-adjusted position sizing.
size = balance * risk_pct / stop_distance
"""

import math
from typing import Dict

from config import RISK_PCT, DEFAULT_BALANCE
from utils.state import get_balance
from utils.indicators import atr_pips  # hypothetical helper; ensure it exists


def size_position(signal: Dict, market: str) -> float:
    """
    Returns the number of contracts / £ per point.
    Assumes `signal["sl"]` already in price units.
    """
    balance = get_balance() if callable(get_balance) else DEFAULT_BALANCE
    stop_distance = abs(signal["entry"] - signal["sl"])
    if stop_distance == 0:
        return 0.0

    # risk = balance * risk_pct  (e.g. 1 %)
    risk_money = balance * RISK_PCT
    size = risk_money / stop_distance

    # sanity cap: do not exceed 5 × mean ATR position
    atr = atr_pips(market)
    max_size = (balance * 0.05) / atr if atr else size
    return round(min(size, max_size), 2)


# === utils\risky.py ===

"""
Volatility-adjusted position sizing.
size = balance * risk_pct / stop_distance
"""

import math
from typing import Dict

from config import RISK_PCT, DEFAULT_BALANCE
from utils.state import get_balance
from utils.indicators import atr_pips  # hypothetical helper; ensure it exists


def size_position(signal: Dict, market: str) -> float:
    """
    Returns the number of contracts / £ per point.
    Assumes `signal["sl"]` already in price units.
    """
    balance = get_balance() if callable(get_balance) else DEFAULT_BALANCE
    stop_distance = abs(signal["entry"] - signal["sl"])
    if stop_distance == 0:
        return 0.0

    # risk = balance * risk_pct  (e.g. 1 %)
    risk_money = balance * RISK_PCT
    size = risk_money / stop_distance

    # sanity cap: do not exceed 5 × mean ATR position
    atr = atr_pips(market)
    max_size = (balance * 0.05) / atr if atr else size
    return round(min(size, max_size), 2)


# === utils\safe_api.py ===

"""
utils/safe_api.py – Wrappers for making IG API calls safely with retries
"""

import time
from config import (
    IG_API_BASE_URL,
    IG_APP_KEY,
    IG_USERNAME,
    IG_PASSWORD,
    IG_ACCOUNT_ID,
    MARKETS
)
from utils.data import fetch_candles

MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds

# Use a supported resolution for verification.
# If your config had CANDLE_RESOLUTION set to "1Min", override it here with a supported string.
SUPPORT_RESOLUTION = "HOUR"

def safe_api_call(func, kwargs: dict, bot_name: str, context: str):
    """
    Calls `func(**kwargs)` with retry logic.
    On failure, logs and returns None.
    """
    for attempt in range(1, MAX_RETRIES + 1):
        try:
            return func(**kwargs)
        except (Exception, TypeError) as e:
            print(f"[{bot_name.upper()}][{context}] Attempt {attempt} failed: {e}")
            if attempt < MAX_RETRIES:
                time.sleep(RETRY_DELAY * attempt)
    print(f"[{bot_name.upper()}][{context}] All {MAX_RETRIES} attempts failed.")
    return None

def verify_ig_login() -> bool:
    """
    Verifies IG API credentials by attempting to fetch a candle.
    Provides confirmation and fallback info for troubleshooting.
    """
    test_market = MARKETS[0]
    print(f"🔄 Checking IG API login with {test_market}...")

    result = safe_api_call(
        fetch_candles,
        kwargs={
            "market":    test_market,
            "timeframe": SUPPORT_RESOLUTION,  # Use supported resolution (e.g., "HOUR")
            "num":       1
        },
        bot_name="launcher",
        context="verify_login"
    )

    if result:
        print(f"✅ IG login confirmed. Candle fetched from {test_market}.")
        return True
    else:
        print(f"❌ IG login failed. No candles returned for {test_market}. Check credentials or API availability.")
        return False


# === utils\session.py ===

# utils/session.py

# Paste in your live session tokens from your login response
CST = "63208fee05ff93753aa1ee0ec3abc7a6c46e7ae39612820dda22e9cd724561CC01112"
X_SECURITY_TOKEN = "1843f5891d8c98c17a48a62663310b4b5a340b5d853c504db3de52710d10d2CD01113"


# === utils\session_timer.py ===

# utils/session_timer.py
from datetime import datetime
def is_trading_session():
    now = datetime.utcnow()
    total = now.hour*60 + now.minute
    return (510 <= total <= 660) or (870 <= total <= 1020)



# === utils\state.py ===

"""
utils/state.py – Tracks account balance and enforces max drawdown
"""

import threading
import requests
from utils.safe_api import safe_api_call
from config import (
    IG_API_BASE_URL,
    IG_APP_KEY,
    RISK_PCT,
    MAX_TOTAL_DAILY_DRAWDOWN_PCT
)

_balance_lock = threading.Lock()
_last_balance = None

def get_auth_headers():
    """
    Retrieve authentication headers (CST, X-SECURITY-TOKEN, API key) from your stored session.
    """
    from utils.session import CST, X_SECURITY_TOKEN
    return {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": CST,
        "X-SECURITY-TOKEN": X_SECURITY_TOKEN,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }

def _fetch_account_details():
    url = f"{IG_API_BASE_URL}/accounts"

    def request_func(url):
        try:
            resp = requests.get(url, headers=get_auth_headers())
            print(f"[STATE][debug] HTTP {resp.status_code} from {url}")
            if resp.status_code == 200:
                return resp.json()
            else:
                print(f"[STATE][error] Unexpected response: {resp.text}")
                return None
        except Exception as e:
            print(f"[STATE][fetch_account] Exception: {e}")
            return None

    return safe_api_call(
        func=request_func,
        kwargs={"url": url},
        bot_name="state",
        context="fetch_account"
    )

def get_balance():
    """
    Safely fetches the balance from the preferred IG account.
    Falls back to last known if parsing fails.
    """
    global _last_balance
    data = _fetch_account_details()

    if data and "accounts" in data:
        preferred = next((a for a in data["accounts"] if a.get("preferred")), None)
        bal = preferred.get("balance") if preferred else None

        if bal is not None:
            try:
                # If the balance is a dictionary, try to extract its numeric value.
                if isinstance(bal, dict):
                    # For example, if bal looks like {"value": "1000.50", "currency": "GBP"}
                    bal = float(bal.get("value", 0))
                else:
                    bal = float(bal)
            except Exception as ex:
                print(f"[state.py] ERROR: Couldn't convert balance to float: {ex}")
                return _last_balance
            with _balance_lock:
                _last_balance = bal
            return bal
        else:
            print("[state.py] WARNING: Preferred account balance not found.")
            return _last_balance

    print("[state.py] WARNING: No account data returned.")
    return _last_balance

def update_balance(delta):
    """
    Applies a profit/loss delta to our tracked balance.
    Ensures that non-numeric deltas are not applied.
    """
    global _last_balance
    try:
        numeric_delta = float(delta)
    except (TypeError, ValueError) as e:
        print(f"[state.py] WARNING: update_balance called with non-numeric delta: {delta}")
        return _last_balance

    with _balance_lock:
        if _last_balance is not None:
            try:
                _last_balance = float(_last_balance) + numeric_delta
            except Exception as e:
                print(f"[state.py] ERROR updating balance. _last_balance: {_last_balance}, delta: {numeric_delta}. Error: {e}")
        else:
            _last_balance = numeric_delta
    return _last_balance

def check_drawdown():
    """
    Checks whether the current balance exceeds the max allowed drawdown.
    Returns False if too much has been lost, True otherwise.
    """
    bal = get_balance()
    if bal and _last_balance:
        drawdown = 1 - (bal / _last_balance)
        return drawdown < MAX_TOTAL_DAILY_DRAWDOWN_PCT
    return True  # Allow trading if unknown


# === utils\stream_fetcher.py ===

# utils/stream_fetcher.py

import threading
import time
from datetime import datetime, timedelta
from collections import deque, defaultdict

from lightstreamer.client import LightstreamerClient, Subscription

# Tick buffers and bar aggregators
_tick_buffers = defaultdict(lambda: deque())
_bar_buffers = defaultdict(lambda: defaultdict(lambda: deque(maxlen=100)))
_lock = threading.Lock()

def _on_item_update(item_update):
    epic = item_update.getItemName()
    price = float(item_update.getValue("LTP") or 0)
    ts = datetime.utcnow()
    with _lock:
        _tick_buffers[epic].append((ts, price))

def start_streaming(api_key, cst, token, epics):
    """
    Connects to IG's Lightstreamer demo endpoint, subscribes to epics,
    and starts a background thread to aggregate 5-minute bars.
    """
    client = LightstreamerClient("https://pushlightstream-demo.ig.com", "QUOTE_ADAPTER")

    # Inject IG authentication headers
    client.connectionDetails.httpExtraHeaders = {
        "X-IG-API-KEY": api_key,
        "CST": cst,
        "X-SECURITY-TOKEN": token
    }

    # Establish connection
    client.connect()

    # Subscribe to Last Traded Price (LTP) updates for each epic
    sub = Subscription("MERGE", epics, ["LTP"])
    sub.setDataAdapter("QUOTE_ADAPTER")
    sub.setRequestedSnapshot("no")
    sub.addListener(_on_item_update)
    client.subscribe(sub)

    # Launch bar aggregation thread
    threading.Thread(target=_aggregate_bars, args=(epics,), daemon=True).start()

def _aggregate_bars(epics):
    """
    Every 5 minutes, builds OHLCV bars from tick buffer.
    """
    while True:
        now = datetime.utcnow()
        next_bound = (now + timedelta(minutes=5)).replace(second=0, microsecond=0)
        time.sleep((next_bound - now).total_seconds())

        with _lock:
            for epic in epics:
                ticks = list(_tick_buffers[epic])
                _tick_buffers[epic].clear()
                if not ticks:
                    continue
                prices = [p for _, p in ticks]
                bar = {
                    "timestamp": next_bound.isoformat(),
                    "open": prices[0],
                    "high": max(prices),
                    "low": min(prices),
                    "close": prices[-1],
                    "volume": len(prices)
                }
                _bar_buffers[epic]["5MINUTE"].append(bar)

def get_stream_bars(epic, resolution):
    """
    Returns aggregated bars for the given resolution.
    Only "5MINUTE" is supported.
    """
    if resolution != "5MINUTE":
        return []
    with _lock:
        return list(_bar_buffers[epic].get("5MINUTE", []))



# === utils\structure.py ===

# utils/structure.py

def detect_swing_breaks(candles):
    """
    Identify clean 3-candle swing breakouts/breakdowns:
    - Bullish: three rising highs then breakout above the highest.
    - Bearish: three falling lows then breakdown below the lowest.
    """
    signals = []
    for i in range(3, len(candles)):
        prev3  = candles[i-3:i]
        highs  = [c["high"] for c in prev3]
        lows   = [c["low"]  for c in prev3]
        current = candles[i]

        # Bullish swing breakout
        if highs[0] < highs[1] < highs[2] and current["close"] > highs[2]:
            signals.append({
                "direction":    "buy",
                "price":        current["close"],
                "ATR":          current["ATR"],
                "breakout":     True,
                "volume":       current["volume"],
                "avg_volume":   current["avg_volume"],
                "ema_distance": current["ema_distance"],
                "session":      current["session"]
            })

        # Bearish swing breakdown
        if lows[0] > lows[1] > lows[2] and current["close"] < lows[2]:
            signals.append({
                "direction":    "sell",
                "price":        current["close"],
                "ATR":          current["ATR"],
                "breakout":     True,
                "volume":       current["volume"],
                "avg_volume":   current["avg_volume"],
                "ema_distance": current["ema_distance"],
                "session":      current["session"]
            })

    return signals

def detect_wick_rejections(candles):
    """
    Identify high-quality wick rejections:
    - Wick length ≥ 1.5×ATR and body ≤ 0.3×ATR.
    """
    signals = []
    for c in candles:
        body = abs(c["close"] - c["open"])
        # Wick calculation depends on bar direction
        if c["close"] < c["open"]:
            wick = max(c["high"] - c["close"], c["high"] - c["open"])
        else:
            wick = max(c["open"] - c["low"], c["close"] - c["low"])
        atr = c["ATR"]

        if wick >= 1.5 * atr and body <= 0.3 * atr:
            signals.append({
                "direction":    "sell" if c["close"] < c["open"] else "buy",
                "price":        c["close"],
                "ATR":          atr,
                "wick_ratio":   wick / body if body > 0 else float("inf"),
                "body_size":    body,
                "wick_size":    wick,
                "volume":       c["volume"],
                "avg_volume":   c["avg_volume"],
                "ema_distance": c["ema_distance"],
                "trend_state":  c["trend_state"],
                "session":      c["session"]
            })

    return signals

def confirm_structure(candles, signal):
    """
    Basic market structure check:
    - For longs: last close > previous close.
    - For shorts: last close < previous close.
    """
    if len(candles) < 2:
        return True
    last_close = candles[-1]["close"]
    prev_close = candles[-2]["close"]
    if signal.get("direction") == "buy":
        return last_close > prev_close
    else:
        return last_close < prev_close



# === utils\trade_executor.py ===

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID
from utils.ig_auth import ig_login

def get_live_ig_balance():
    """
    Retrieves your live account balance from the /accounts endpoint.
    Searches for the account with accountId "Z4NFPN" (your spread betting account).
    """
    tokens = ig_login()
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "X-IG-ACCOUNT-ID": IG_ACCOUNT_ID,
        "CST": tokens.get("CST", ""),
        "X-SECURITY-TOKEN": tokens.get("X-SECURITY-TOKEN", ""),
        "Accept": "application/json"
    }
    response = requests.get(f"{IG_API_BASE_URL}/accounts", headers=headers, timeout=10)
    response.raise_for_status()
    data = response.json()
    
    accounts = data.get("accounts")
    if not accounts:
        raise ValueError("No accounts found in response")
    
    for account in accounts:
        if account.get("accountId") == "Z4NFPN":
            balance = account.get("accountInfo", {}).get("balance")
            if balance is None:
                raise ValueError("Balance field not found")
            return float(balance)
    
    balance = accounts[0].get("accountInfo", {}).get("balance")
    if balance is None:
        raise ValueError("Balance field not found")
    return float(balance)


# === utils\trailing_stop.py ===

# utils/trailing_stop.py

import threading
import time
from utils.data_fetcher import get_session
from config import IG_API_BASE_URL

def monitor_position(deal_ref, epic, direction, atr, initial_sl):
    """
    Monitors a live spread-bet position and updates its stop-loss to trail the price by 1×ATR.
    """
    sl = initial_sl
    while True:
        time.sleep(30)  # check every 30 seconds
        session = get_session()
        try:
            # Fetch the latest 1-minute bar to get the current close price
            resp = session.get(
                f"{IG_API_BASE_URL}/prices/{epic}/HISTORICAL/1MINUTE",
                params={"max": 1},
                timeout=10
            )
            resp.raise_for_status()
            data = resp.json().get("prices", []) or resp.json().get("candles", [])
            if not data:
                continue
            last_price = data[-1]["close"]
        except Exception:
            continue

        # Calculate a new stop-loss one ATR behind the current price
        new_sl = (last_price - atr) if direction == "buy" else (last_price + atr)

        # Only move the stop in the favorable direction
        if direction == "buy" and new_sl > sl:
            payload = {"dealReference": deal_ref, "stopLevel": new_sl}
            session.put(f"{IG_API_BASE_URL}/positions/{deal_ref}", json=payload)
            sl = new_sl
        elif direction == "sell" and new_sl < sl:
            payload = {"dealReference": deal_ref, "stopLevel": new_sl}
            session.put(f"{IG_API_BASE_URL}/positions/{deal_ref}", json=payload)
            sl = new_sl
