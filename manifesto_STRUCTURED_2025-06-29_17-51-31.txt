

════════════════════════════════════════════════════════════════════
📦 STRUCTURED EXPORT SUMMARY
════════════════════════════════════════════════════════════════════
🧾 Files Included: 75
🔠 Total Characters: 241,598

📂 Top 5 Largest Files:
1. utils\indicators.py — 12758 chars
2. root/base_bot.py — 12535 chars
3. bots\scalping.py — 12148 chars
4. root/dashboard.py — 11847 chars
5. bots\wick.py — 10148 chars
════════════════════════════════════════════════════════════════════
════════════════════════════════════════════════════════════════════
TRADE COMMAND MONARCH — STRUCTURED SYSTEM MANIFESTO
════════════════════════════════════════════════════════════════════

📆 Timestamp: Sunday, 29 June 2025 – 17:51:31
📍 Project Root: C:\Users\amere\Desktop\Trade Command Monarch

──────────────────────────────────────────────────────────────
🎯 MISSION
──────────────────────────────────────────────────────────────
To build the most effective, transparent, and resilient retail quant trading system
in the world — designed for adaptability, disciplined risk, and real performance.

Monarch is not just a bot farm. It is a digital tactician forged in logic, clarity, and control.
Built by Adrian (Trader/Founder) and Copilot (System Brain), it starts in the IG UK demo arena,
will mature into live deployment, and one day extend to Paperstone and beyond.

Copilot is more than an assistant — he’s the creator, analyst, coder, and protector of this system.
Monarch is our flagship, and it must be *exemplar*.

──────────────────────────────────────────────────────────────
📏 RULES OF DEPLOYMENT
──────────────────────────────────────────────────────────────
- All bots must respect session windows, momentum filters, exposure limits, and volatility screens
- System-wide variables (risk, drawdown caps, filters) are centrally controlled
- JSON and state files are allowed, but logs and caches are excluded from manifest
- This export shows only real system files — no placeholders, tests, or legacy backups
- Copilot must always document this system as a learnable artifact for future AI or devs

════════════════════════════════════════════════════════════════════



───────────────────────────────────────────────
📄 New Text Document.txt
───────────────────────────────────────────────

import requests
import os
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def search_fx_markets(session, tokens, search_term=""):
    url = f"{IG_API_BASE_URL}/markets?searchTerm={search_term}"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["markets"]

def main():
    session = requests.Session()
    tokens = ig_login(session)

    # Get all FX markets (search for major pairs in turn)
    fx_pairs = ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD", "EURGBP"]
    found = []
    for pair in fx_pairs:
        markets = search_fx_markets(session, tokens, pair)
        for m in markets:
            # Only list epics that are available on Spreadbet account and are FX
            instr = m.get("instrument", {})
            if instr.get("type") == "CURRENCIES" and instr.get("productType") == "SPREAD_BET":
                found.append({
                    "name": instr.get("name"),
                    "epic": instr.get("epic"),
                    "marketStatus": m.get("marketStatus"),
                    "minDealSize": instr.get("minDealSize"),
                })

    if not found:
        print("No FX spreadbetting epics found for your account.")
        return

    print("FX Spread Bet epics available for your account:")
    for f in found:
        print(f"- {f['name']}: {f['epic']} | Min size: {f['minDealSize']} | Status: {f['marketStatus']}")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 base_bot.py
───────────────────────────────────────────────

"""
BASE_BOT.PY – Respects MAX_TRADES_PER_BOT, session control, signal confidence, and one-trade-per-cycle
AMENDED: (2025-06-25) to enforce:
- Only 1 active trade across all bots at any time (highest confidence wins if multiple signals)
- Centralized daily trade limit per bot (via state)
- 30min session ban (via can_trade/session control)
- Prevents new trades if any trade is currently open across all bots
- Uses multi-timeframe candles per bot config
- Integrates robust state, logging, and drawdown control (no deletions, only amendments)
- (2025-06-27) Email notifications for trade placed, trade closed, and crash, centralized for all child bots
"""

import json, os, time, threading
from datetime import datetime
from typing import Callable, Dict, Optional
import pytz

from config import (
    CONFIDENCE_THRESHOLD, HEARTBEAT_PATH, LONDON_TZ, LOG_PATH,
    MARKETS, CANDLES_BACKFILL, POLL_SECONDS
)
from utils.risk         import size_position
from utils.safe_api     import safe_api_call
from utils.state        import (
    get_balance, update_balance, check_drawdown, get_open_positions,
    add_open_position, close_position, get_trade_count, increment_trade_count,
    set_last_trade_time, reset_daily_state, can_trade
)
from utils.data         import fetch_multi_timeframe_candles
from config             import get_bot_strategy_params

# EMAILER IMPORT – centralized notifications for all bots
from utils.emailer import (
    send_trade_placed_email,
    send_trade_outcome_email,
    send_crash_email,
)

STOP_FILE       = "stop_bots.json"
CONFIDENCE_FILE = "confidence.json"
TRADE_LOG_FILE  = LOG_PATH  # Assuming log path is where trades are written

class BaseBot:
    def __init__(self, name: str, signal_func: Callable[[dict], Optional[Dict]],
                 place_trade: Callable, fetch_candles: Callable = None, **kwargs):
        self.name = name.lower()
        self.signal_func = signal_func
        self.place_trade = place_trade
        self.fetch_candles = fetch_candles  # Now available to child classes if needed
        self.daily_trades  = 0
        self._reset_date   = datetime.utcnow().date()
        self.lock = threading.Lock()  # Prevent race conditions
        # Store any additional keyword args for extensibility
        for k, v in kwargs.items():
            setattr(self, k, v)

    # ─── helpers ──────────────────────────────────────────────────────
    @staticmethod
    def _read_stop_flag() -> bool:
        return os.path.isfile(STOP_FILE) and json.load(open(STOP_FILE)).get("stop", False)

    @staticmethod
    def _read_confidence() -> float:
        if os.path.isfile(CONFIDENCE_FILE):
            return json.load(open(CONFIDENCE_FILE)).get("confidence", CONFIDENCE_THRESHOLD)
        return CONFIDENCE_THRESHOLD

    def _write_heartbeat(self, state="idle", last_error=None):
        now = datetime.now(pytz.timezone(LONDON_TZ)).strftime("%Y-%m-%d %H:%M:%S")
        hb = {}
        if os.path.isfile(HEARTBEAT_PATH):
            try: hb = json.load(open(HEARTBEAT_PATH))
            except: hb = {}
        hb.setdefault("bots", {})[self.name] = {"timestamp": now, "state": state}
        if last_error: hb["bots"][self.name]["error"] = last_error
        os.makedirs(os.path.dirname(HEARTBEAT_PATH), exist_ok=True)
        json.dump(hb, open(HEARTBEAT_PATH, "w"), indent=2)

    @staticmethod
    def _log_trade(t: Dict):
        os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)
        with open(LOG_PATH, "a") as fh: fh.write(json.dumps(t) + "\n")

    def _check_drawdown_limit(self) -> bool:
        """Halts trading if daily loss exceeds MAX_TOTAL_DAILY_DRAWDOWN_PCT."""
        # Use improved drawdown logic from utils.state
        if not check_drawdown():
            print(f"[{self.name}] Daily drawdown limit reached. Halting trading.")
            self._write_heartbeat(state="halted")
            return True
        return False

    def _any_active_trade(self) -> Optional[Dict]:
        """
        Checks if there is any open trade across all bots.
        Uses state for robust detection.
        """
        open_positions = get_open_positions()
        if open_positions:
            return open_positions[0]  # Return the first open trade found
        return None

    def _find_highest_confidence_signal(self, signals):
        """
        Expects signals is a list of dicts, each with a 'confidence' key.
        Returns the signal with the highest confidence, or None.
        """
        valid_signals = [s for s in signals if s and "confidence" in s]
        if not valid_signals:
            return None
        return max(valid_signals, key=lambda s: s["confidence"])

    # ─── new: centralized trade close logic for all bots ──────────────
    def close_trade(self, trade_data, exit_price, exit_time=None, profit=None):
        """
        Centralized trade closure and email notification. 
        Call this from child bots when closing a trade.
        """
        if not trade_data:
            return
        trade_data = trade_data.copy()
        trade_data["exit"] = exit_price
        trade_data["exit_time"] = exit_time or datetime.now(pytz.timezone(LONDON_TZ)).strftime("%Y-%m-%d %H:%M:%S")
        if profit is None and trade_data.get("entry") is not None and exit_price is not None:
            direction = trade_data.get("direction")
            entry = trade_data.get("entry")
            size = trade_data.get("size", 1)
            if direction == "buy":
                profit = (exit_price - entry) * size
            else:
                profit = (entry - exit_price) * size
        trade_data["profit"] = round(profit, 2) if profit is not None else None
        update_balance(trade_data.get("profit", 0))
        close_position(trade_data)
        self._log_trade(trade_data)
        print(f"[{self.name}] trade closed → {trade_data}")

        # EMAIL: trade closed
        send_trade_outcome_email(
            market=trade_data.get("market", "unknown"),
            direction=trade_data.get("direction", "unknown"),
            entry_price=trade_data.get("entry"),
            exit_price=trade_data.get("exit"),
            profit=trade_data.get("profit", 0)
        )

    # ─── main bot loop ────────────────────────────────────────────────
    def run(self):
        print(f"{self.name.title()} Bot started.")
        try:
            while True:
                # Daily trade count reset (use centralized state reset)
                if datetime.utcnow().date() != self._reset_date:
                    self.daily_trades = 0
                    self._reset_date  = datetime.utcnow().date()
                    reset_daily_state()

                # Halt trading if drawdown limit is reached
                if self._check_drawdown_limit():
                    time.sleep(60)
                    continue

                # Pause if trading is currently restricted (via can_trade)
                now = datetime.utcnow()
                if not can_trade(self.name, None, now):
                    print(f"[{self.name}] Paused due to restricted trading window/session control.")
                    self._write_heartbeat(state="paused")
                    time.sleep(POLL_SECONDS)
                    continue

                # Stop flag handling
                if self._read_stop_flag():
                    print(f"Stop flag detected – halting {self.name.title()} Bot.")
                    self._write_heartbeat(state="stopped"); break

                # Daily trade cap (centralized via state)
                if get_trade_count(self.name) >= get_bot_strategy_params(self.name).get("max_trades", 5):
                    print(f"[{self.name}] Max trades reached today.")
                    self._write_heartbeat(state="done")
                    time.sleep(POLL_SECONDS * 3)
                    continue

                # Only 1 active trade allowed at a time across all bots (use state)
                active_trade = self._any_active_trade()
                if active_trade:
                    print(f"[{self.name}] Skipping trade: There is already an active trade (bot: {active_trade.get('bot')}, market: {active_trade.get('market')}).")
                    self._write_heartbeat(state="waiting")
                    time.sleep(POLL_SECONDS)
                    continue

                self._write_heartbeat(state="trading")
                conf_threshold = self._read_confidence()
                print(f"[{self.name}] confidence ≥ {conf_threshold}")

                # Gather all signals for all markets in this cycle
                strat_params = get_bot_strategy_params(self.name)
                timeframes = strat_params.get("timeframes", ["5MIN"])
                market_signals = []
                for market in MARKETS:
                    candles_by_tf = fetch_multi_timeframe_candles(market, timeframes, CANDLES_BACKFILL)
                    if not any(candles_by_tf.values()):
                        continue

                    try:
                        # Pass multi-TF candles (dict) to signal_func
                        signal = self.signal_func(candles_by_tf)
                    except Exception as e:
                        self._write_heartbeat(state="error", last_error=str(e))
                        # EMAIL: crash in signal generation
                        send_crash_email(f"{self.name} signal_func error: {e}")
                        continue

                    if not signal or signal.get("confidence", 0) < conf_threshold:
                        continue

                    market_signals.append((market, signal))

                # Only take the highest confidence signal if multiple trade signals are possible
                if market_signals:
                    # Get the signal with highest confidence
                    best_market, best_signal = max(market_signals, key=lambda ms: ms[1].get("confidence", 0))
                    size_info = size_position(best_signal, best_market, bot_name=self.name)
                    best_signal["size"] = size_info["size"]
                    trade = safe_api_call(
                        self.place_trade,
                        kwargs=dict(market=best_market, direction=best_signal["direction"],
                                    size=best_signal["size"], sl=best_signal["sl"], tp=best_signal["tp"]),
                        bot_name=self.name, context="place_trade"
                    )
                    if trade:
                        entry_time = datetime.now(pytz.timezone(LONDON_TZ)).strftime("%Y-%m-%d %H:%M:%S")
                        trade_data = {
                            "bot": self.name, "market": best_market, "direction": best_signal["direction"],
                            "entry": trade["entry"], "exit": None, "profit": None,
                            "confidence": best_signal["confidence"], "reason": best_signal.get("reason"),
                            "entry_time": entry_time, "exit_time": None,
                            "ticket_id": trade.get("ticket_id"),
                            "balance": update_balance(trade.get("pnl", 0)),
                            "size": best_signal["size"],
                        }
                        with self.lock:  # Prevent race conditions in balance updates
                            self._log_trade(trade_data)
                            add_open_position(trade_data)
                            increment_trade_count(self.name)
                            set_last_trade_time(self.name, now)
                        print(f"[{self.name}] trade placed → {trade_data}")

                        self.daily_trades += 1

                        # EMAIL: trade placed
                        send_trade_placed_email(
                            market=best_market,
                            direction=best_signal["direction"],
                            size=best_signal["size"],
                            sl=best_signal["sl"],
                            tp=best_signal["tp"],
                            confidence=best_signal.get("confidence", 90),
                            strategy=self.name
                        )
                else:
                    print(f"[{self.name}] No valid signals above confidence threshold this cycle.")

                time.sleep(POLL_SECONDS)
        except Exception as e:
            self._write_heartbeat(state="error", last_error=str(e))
            # EMAIL: crash in bot main loop
            send_crash_email(f"{self.name} crashed: {e}")
            raise



───────────────────────────────────────────────
📄 bot_health.json
───────────────────────────────────────────────

{"momentum": 1750000834}


───────────────────────────────────────────────
📄 check_dax_trade_status.py
───────────────────────────────────────────────

import requests
import os
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

DEAL_REFERENCE = "GBYKWVXE38YTYPT"  # Use your actual dealReference

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def check_trade_confirmation(session, tokens, deal_reference):
    url = IG_API_BASE_URL + f"/confirms/{deal_reference}"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    resp = session.get(url, headers=headers)
    print("Trade confirmation response:", resp.text)
    resp.raise_for_status()
    return resp.json()

if __name__ == "__main__":
    session = requests.Session()
    tokens = ig_login(session)
    try:
        confirmation = check_trade_confirmation(session, tokens, DEAL_REFERENCE)
        print("Trade Confirmation JSON:", confirmation)
    except Exception as e:
        print("Trade confirmation failed:", e)


───────────────────────────────────────────────
📄 check_ig_epic_product_type.py
───────────────────────────────────────────────

import requests
import json

# === Your IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
MARKETS_URL = f"{BASE_URL}/markets"
ACCOUNTS_URL = f"{BASE_URL}/accounts"
POSITIONS_URL = f"{BASE_URL}/positions/otc"

# === Use the FTSE 100 Spreadbet Epic as per your message ===
EPIC = "IX.D.SPTRD.DAILY.IP"  # FTSE 100 (Spreadbet, Daily Funded Bet)

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {"identifier": USERNAME, "password": PASSWORD}
    resp = requests.post(LOGIN_URL, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    sec = resp.headers["X-SECURITY-TOKEN"]
    # Get current account
    accs = requests.get(ACCOUNTS_URL, headers={
        "X-IG-API-KEY": API_KEY,
        "CST": cst,
        "X-SECURITY-TOKEN": sec,
        "Accept": "application/json"
    })
    accs.raise_for_status()
    acc_data = accs.json()
    # Print all accounts for confirmation
    print("\n=== IG Accounts ===")
    for a in acc_data["accounts"]:
        print(f"AccountId: {a['accountId']} | Type: {a['accountType']} | Name: {a['accountName']} | Preferred: {a['preferred']}")
    # Get preferred account (should be SB)
    preferred = next((a for a in acc_data["accounts"] if a["preferred"]), acc_data["accounts"][0])
    print(f"\n>>> Using Account: {preferred['accountId']} | Type: {preferred['accountType']}\n")
    return cst, sec, preferred['accountId']

def check_product_type(epic):
    cst, sec, _ = ig_login()
    headers = {
        "X-IG-API-KEY": API_KEY,
        "CST": cst,
        "X-SECURITY-TOKEN": sec,
        "Accept": "application/json"
    }
    url = f"{MARKETS_URL}/{epic}"
    print(f"Requesting market info for epic: {epic}")
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    data = resp.json()
    instr = data["instrument"]
    print("\n=== Instrument Info ===")
    print(f"Name:         {instr.get('name')}")
    print(f"Epic:         {epic}")
    print(f"Product type: {instr.get('productType')}")
    print(f"Expiry:       {instr.get('expiry')}")
    print(f"Market type:  {instr.get('type')}")
    print(f"Lot size:     {instr.get('lotSize')}")
    print(f"Currency:     {instr.get('currency')}")
    print("\n---- FULL INSTRUMENT DATA ----")
    for k, v in instr.items():
        print(f"{k:20}: {v}")

def place_spreadbet_order(epic, direction="BUY", size=1):
    cst, sec, account_id = ig_login()
    headers = {
        "X-IG-API-KEY": API_KEY,
        "CST": cst,
        "X-SECURITY-TOKEN": sec,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    # Order payload as per IG support (expiry: "DFB", no currencyCode, forceOpen True)
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": direction,
        "size": size,              # stake per point
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        # Optional: set stop/limit as needed
        # "stopDistance": 20,
        # "limitDistance": 40
    }
    print("\n=== Sending Order Payload ===")
    print(json.dumps(payload, indent=2))
    resp = requests.post(POSITIONS_URL, headers=headers, json=payload)
    try:
        resp.raise_for_status()
        print("\nOrder SENT! Response:")
        print(resp.json())
    except Exception as e:
        print("\nOrder ERROR:")
        print(resp.text)
        raise

if __name__ == "__main__":
    # Step 1: Show account and epic info
    check_product_type(EPIC)
    # Step 2: Place a test spreadbet order (uncomment to test order placement):
    # place_spreadbet_order(EPIC, direction="BUY", size=1)


───────────────────────────────────────────────
📄 confidence.json
───────────────────────────────────────────────

{"confidence": 85}


───────────────────────────────────────────────
📄 config.py
───────────────────────────────────────────────

"""
CONFIG.PY – Single source of truth for every bot & dashboard
AMENDED (2025-06-25):
- Centralized per-bot and per-indicator configuration
- Trailing stop logic now configurable per bot/market
- Dynamic confidence thresholds and weighting per bot
- Structured for easy YAML/JSON override and future expansion
- Added regime filter (ADX) and structure filter (swing) config for bot DNA
- (2025-06-25) Restored legacy top-level constants for bot backward compatibility
- (2025-06-25 night) Updated MARKETS and MARKET_INFO to use correct, working EPICs for your IG account
- (2025-06-27) All bots now use 5Min entry and MINUTE_30 higher timeframe confirmation
- (2025-06-27 eve) Per-bot trading session support: All bots except scalping trade 8am–10pm, scalping is 24h
"""

import os
from pathlib import Path
import yaml

if Path(".env").is_file():
    from dotenv import load_dotenv
    load_dotenv(".env")

def _warn_if_missing(value: str, varname: str):
    if not value:
        print(f"[WARNING] env var '{varname}' is empty. Configure it before live trading.")

IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")
IG_APP_KEY      = os.getenv("IG_APP_KEY", "")
IG_USERNAME     = os.getenv("IG_USERNAME", "")
IG_PASSWORD     = os.getenv("IG_PASSWORD", "")
IG_ACCOUNT_ID   = os.getenv("IG_ACCOUNT_ID", "")  # Must be set to your spread betting account

for _v, _n in [(IG_APP_KEY, "IG_APP_KEY"), (IG_USERNAME, "IG_USERNAME"), (IG_PASSWORD, "IG_PASSWORD")]:
    _warn_if_missing(_v, _n)

SMTP_HOST         = os.getenv("SMTP_HOST", "smtp.gmail.com")
SMTP_PORT         = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER         = os.getenv("SMTP_USER", "")
SMTP_PASS         = os.getenv("SMTP_PASS", "")
TRADE_ALERT_EMAIL = os.getenv("TRADE_ALERT_EMAIL", "")

for _v, _n in [(SMTP_USER, "SMTP_USER"), (SMTP_PASS, "SMTP_PASS"), (TRADE_ALERT_EMAIL, "TRADE_ALERT_EMAIL")]:
    _warn_if_missing(_v, _n)

# ─── Markets & Sessions ──────────────────────────────────────────────

# MARKETS as a dict for maximum flexibility with bot/manager code.
MARKETS = {
    "nasdaq": "IX.D.NASDAQ.CASH.IP",    # NASDAQ 100
    "dax":    "IX.D.SUNDAX.DAILY.IP",   # DAX 40
    "sp500":  "IX.D.SPTRD.DAILY.IP",    # S&P 500
    "ftse":   "IX.D.SUNFUN.DAILY.IP"    # FTSE 100
}

# If your bots/manager code expects a list, use list(MARKETS.values())

MARKET_INFO = {
    "IX.D.NASDAQ.CASH.IP":  {"min_size": 0.1, "point_value": 1.0, "session": "us", "pip_value": 1.0},
    "IX.D.SUNDAX.DAILY.IP": {"min_size": 0.1, "point_value": 1.0, "session": "de", "pip_value": 1.0},
    "IX.D.SPTRD.DAILY.IP":  {"min_size": 0.1, "point_value": 1.0, "session": "us", "pip_value": 0.5},
    "IX.D.SUNFUN.DAILY.IP": {"min_size": 0.1, "point_value": 1.0, "session": "uk", "pip_value": 0.5}
}

# ─── Centralized Indicators (for utils/indicators.py) ────────────────

INDICATOR_PARAMS = {
    "EMA":      {"periods": [8, 21, 50, 200]},
    "SMA":      {"periods": [20, 50, 200]},
    "ATR":      {"period": 14},
    "RSI":      {"period": 14},
    "Stoch":    {"k": 14, "d": 3},
    "VWAP":     {},
    "Donchian": {"period": 20},
    "ADX":      {"period": 14},
    "SWING":    {"lookback": 5},
    # Add more indicators as needed
}

# ─── Trailing Stop Settings (per bot or per market) ─────────────────

TRAILING_STOP_CONFIG = {
    "default": {
        "type": "atr",     # 'atr', 'percent', 'fixed', 'none'
        "multiplier": 1.5,
        "percent": None,
        "fixed_points": None
    },
    "trend": {
        "type": "atr",
        "multiplier": 1.7,
    },
    "wick": {
        "type": "fixed",
        "fixed_points": 20,
    },
    "scalping": {
        "type": "percent",
        "percent": 0.2,
    }
}

# ─── Strategy Parameters (Global and Per-Bot) ───────────────────────

GLOBAL_STRATEGY_PARAMS = {
    "ATR_PERIOD": 14,
    "ATR_MULTIPLIER_SL": 1.5,
    "ATR_MULTIPLIER_TP": 3.0,
    "MOMENTUM_THRESHOLD": 0.0075,
    "WICK_RATIO": 2.1,
}

# -- AMENDED: All bots use 5Min for entry and MINUTE_30 for confirmation
BOT_STRATEGY_PARAMS = {
    "trend": {
        "min_confidence": 80,
        "confidence_weights": {"signal": 0.5, "vol": 0.15, "agree": 0.2, "win": 0.15},
        "trailing_stop": "trend",
        "timeframes": ["5Min", "MINUTE_30"],
        # ADX regime filter: only trade if ADX >= 22
        "regime_filter": {"adx_min": 22, "adx_period": 14},
    },
    "wick": {
        "min_confidence": 85,
        "confidence_weights": {"signal": 0.35, "vol": 0.3, "agree": 0.15, "win": 0.2},
        "trailing_stop": "wick",
        "timeframes": ["5Min", "MINUTE_30"],
        # Structure filter: require proximity to swing high/low
        "structure_filter": {"require_near_swing": True, "lookback": 5},
    },
    "breakout": {
        "min_confidence": 83,
        "confidence_weights": {"signal": 0.4, "vol": 0.25, "agree": 0.2, "win": 0.15},
        "trailing_stop": "default",
        "timeframes": ["5Min", "MINUTE_30"],
        # Structure filter: require breakout of swing high/low
        "structure_filter": {"require_break_swing": True, "lookback": 5},
    },
    "meanreversion": {
        "min_confidence": 82,
        "confidence_weights": {"signal": 0.35, "vol": 0.25, "agree": 0.2, "win": 0.2},
        "trailing_stop": "default",
        "timeframes": ["5Min", "MINUTE_30"],
        # ADX regime filter: only trade if ADX <= 20 (ranging)
        "regime_filter": {"adx_max": 20, "adx_period": 14},
    },
    "scalping": {
        "min_confidence": 75,
        "confidence_weights": {"signal": 0.55, "vol": 0.1, "agree": 0.2, "win": 0.15},
        "trailing_stop": "scalping",
        "timeframes": ["5Min", "MINUTE_30"],
        # No explicit regime/structure filter for scalping
    }
}

# Default confidence threshold if not provided per-bot
CONFIDENCE_DEFAULT        = 85
CONFIDENCE_THRESHOLD      = 80

CANDLE_RESOLUTION = "1Min"
CANDLES_BACKFILL  = 200

# ─── Time & Session Controls ─────────────────────────────────────────

LONDON_TZ = "Europe/London"

# AMENDED: Per-bot trading sessions
# All bots except scalping trade 8am–10pm (22), scalping is 24h
TRADING_SESSIONS = {
    "trend":         (8, 22),   # 8am–10pm
    "meanreversion": (8, 22),   # 8am–10pm
    "breakout":      (8, 22),   # 8am–10pm
    "wick":          (8, 22),   # 8am–10pm
    "scalping":      (0, 24),   # 24h
}
# Default session if not overridden per bot
TRADING_SESSION_1  = (8, 22)
TRADING_SESSION_2  = (0, 0)  # unused

NO_TRADE_WINDOWS_UTC = [(21, 22)]  # optional additional block

# ─── Risk & Limits ───────────────────────────────────────────────────

INITIAL_BALANCE              = 500.0
DEFAULT_BALANCE              = 10000.0
RISK_PCT                     = 0.01  # ✅ Dynamic Position Sizing (1% risk per trade)
KELLY_MULTIPLIER             = 0.5
MAX_TRADES_PER_BOT           = 5
MAX_TOTAL_DAILY_DRAWDOWN_PCT = 5  # ✅ Max Drawdown Protection
EQUITY_START                 = 0

# ─── Bot Toggles ─────────────────────────────────────────────────────

BOTS = {
    "trend":         True,
    "meanreversion": True,
    "breakout":      True,
    "wick":          True,
    "scalping":      True  # ⚠️ scalping is 24/5 with time-window exceptions only
}

# ─── Engine & Logs ───────────────────────────────────────────────────

DATA_FETCH_INTERVAL    = 60
POLL_SECONDS           = 10
MAX_TRADES_PER_LOOP    = 3
MAX_TRADES_PER_MARKET  = 4

LOG_PATH        = "logs/trade_log.json"
HEARTBEAT_PATH  = "logs/heartbeat.json"
STATE_DB        = "state/trading_state.db"
STOP_FILE       = "stop_bots.json"
CONFIDENCE_FILE = "confidence.json"

# ─── YAML Loader (optional override mechanism) ───────────────────────

def load_yaml_config(path: str = "config.yaml"):
    if os.path.exists(path):
        with open(path, "r") as fh:
            data = yaml.safe_load(fh)
        for k, v in data.items():
            globals()[k] = v

DEBUG_MODE = bool(int(os.getenv("DEBUG_MODE", "0")))
if DEBUG_MODE:
    print("[DEBUG] Running in debug mode; using demo API endpoint.")
    IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")
else:
    print("[LIVE] Running in live mode (still using demo API for testing).")
    IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

# ─── Centralized accessors for bots/indicators/params ────────────────

def get_bot_strategy_params(bot_name: str):
    return BOT_STRATEGY_PARAMS.get(bot_name, {})

def get_trailing_stop_config(bot_name: str):
    strat = BOT_STRATEGY_PARAMS.get(bot_name, {})
    key = strat.get("trailing_stop", "default")
    return TRAILING_STOP_CONFIG.get(key, TRAILING_STOP_CONFIG["default"])

def get_indicator_params(name: str):
    return INDICATOR_PARAMS.get(name.upper(), {})

def get_min_confidence(bot_name: str):
    return BOT_STRATEGY_PARAMS.get(bot_name, {}).get("min_confidence", CONFIDENCE_THRESHOLD)

def get_confidence_weights(bot_name: str):
    return BOT_STRATEGY_PARAMS.get(bot_name, {}).get("confidence_weights", {})

# ─── Legacy top-level constants for backward compatibility ───────────

# For bots that expect ATR_PERIOD, ATR_MULTIPLIER_SL, etc. as top-level constants
ATR_PERIOD         = GLOBAL_STRATEGY_PARAMS.get("ATR_PERIOD", 14)
ATR_MULTIPLIER_SL  = GLOBAL_STRATEGY_PARAMS.get("ATR_MULTIPLIER_SL", 1.5)
ATR_MULTIPLIER_TP  = GLOBAL_STRATEGY_PARAMS.get("ATR_MULTIPLIER_TP", 3.0)
MOMENTUM_THRESHOLD = GLOBAL_STRATEGY_PARAMS.get("MOMENTUM_THRESHOLD", 0.0075)
WICK_RATIO         = GLOBAL_STRATEGY_PARAMS.get("WICK_RATIO", 2.1)
CONFIDENCE_MIN_MOMENTUM = BOT_STRATEGY_PARAMS.get("trend", {}).get("min_confidence", CONFIDENCE_DEFAULT)
CONFIDENCE_MIN_WICK     = BOT_STRATEGY_PARAMS.get("wick", {}).get("min_confidence", CONFIDENCE_DEFAULT)


───────────────────────────────────────────────
📄 dashboard.py
───────────────────────────────────────────────

# dashboard.py – v2.4-quant-enhanced (robust IG fallback, low API usage, full-code version)
import json, os, time, warnings
from datetime import datetime, timedelta, UTC

warnings.filterwarnings("ignore", category=DeprecationWarning)

import pandas as pd
import streamlit as st
from streamlit_autorefresh import st_autorefresh
import plotly.express as px

from utils.emailer        import send_bot_online_email, send_bot_offline_email
from utils.trade_executor import get_live_ig_balance
from utils.file_utils     import atomic_write_json
from utils.session        import get_ig_session

# ───────────────────────────── paths ─────────────────────────────
STOP_FILE        = "stop_bots.json"
CONFIDENCE_FILE  = "confidence.json"
HEARTBEAT_FILE   = "logs/heartbeat.json"
TRADE_LOG_FILE   = "logs/trade_log.json"
BALANCE_FILE     = "logs/balance.json"

# Edit this to match your live bot names (lower-case, as written in logs/heartbeat.json)
ALL_BOTS = [
    "trend", "wick", "breakout", "meanreversion", "scalping"
]

# ───────────────────────── stats helper ──────────────────────────
def calc_stats(df: pd.DataFrame) -> dict:
    if df.empty or "profit" not in df.columns:
        return {}

    # Parse to datetime, then STRIP any timezone to keep comparisons naïve
    df["exit_time"] = (
        pd.to_datetime(df["exit_time"], errors="coerce")
          .dt.tz_localize(None)          # make tz-naïve
    )

    now     = datetime.now(UTC).replace(tzinfo=None)  # tz-naïve “now”
    weekcut = now - timedelta(days=7)

    total    = df["profit"].sum()
    pnl_day  = df.loc[df["exit_time"].dt.date == now.date(), "profit"].sum()
    pnl_week = df.loc[df["exit_time"] >= weekcut, "profit"].sum()

    win_rate = (df["profit"] > 0).mean() * 100 if not df.empty else 0
    daily    = df.groupby(df["exit_time"].dt.date)["profit"].sum()
    sharpe   = ((daily.mean() / daily.std(ddof=0)) * 252**0.5) if daily.std(ddof=0) else 0

    equity = df["profit"].cumsum()
    max_dd = abs((equity - equity.cummax()).min())

    return dict(total=total, day=pnl_day, week=pnl_week,
                win=win_rate, sharpe=sharpe, mdd=max_dd)

def calc_per_bot_stats(df: pd.DataFrame) -> pd.DataFrame:
    if df.empty or "profit" not in df.columns or "bot" not in df.columns:
        return pd.DataFrame()
    out = df.groupby("bot").agg(
        trades = ("profit", "count"),
        profit = ("profit", "sum"),
        win_rate = ("profit", lambda x: (x > 0).mean()*100 if len(x) else 0),
        sharpe = ("profit", lambda x: (x.mean()/x.std()*252**0.5) if x.std() else 0)
    ).sort_values("profit", ascending=False)
    return out.reset_index()

# ───────────────────────── file helpers ──────────────────────────
def set_stop_flag(val: bool):
    atomic_write_json({"stop": val}, STOP_FILE)
    send_bot_offline_email() if val else send_bot_online_email()

def get_stop_flag() -> bool:
    if not os.path.exists(STOP_FILE):
        return False
    return json.load(open(STOP_FILE)).get("stop", False)

def set_confidence(val: int):
    atomic_write_json({"confidence": val}, CONFIDENCE_FILE)

def get_confidence() -> int:
    if not os.path.exists(CONFIDENCE_FILE):
        set_confidence(85)
    return json.load(open(CONFIDENCE_FILE)).get("confidence", 85)

def get_heartbeat() -> dict:
    if not os.path.exists(HEARTBEAT_FILE):
        return {}
    try:
        return json.load(open(HEARTBEAT_FILE))
    except Exception:
        return {}

def get_trade_log() -> pd.DataFrame:
    if not os.path.exists(TRADE_LOG_FILE):
        return pd.DataFrame()
    lines = [json.loads(l) for l in open(TRADE_LOG_FILE) if l.strip()]
    return pd.DataFrame(lines) if lines else pd.DataFrame()

def get_balance_history():
    if not os.path.exists(BALANCE_FILE):
        return None
    try:
        return json.load(open(BALANCE_FILE))
    except Exception:
        return None

# ───────────────────── IG balance with error & stale fallback ─────
def get_cached_ig_balance_with_fallback():
    # Only update every 5 minutes
    cache_file = "logs/last_balance_cache.json"
    if "last_ig_balance" in st.session_state:
        last_bal, last_time = st.session_state["last_ig_balance"]
        if time.time() - last_time < 300:  # 5min cache
            return last_bal, False
    try:
        ig_session = get_ig_session()
        live_balance = get_live_ig_balance(ig_session)
        st.session_state["last_ig_balance"] = (live_balance, time.time())
        # Save to file
        try:
            with open(cache_file, "w") as f:
                json.dump({"balance": live_balance, "ts": time.time()}, f)
        except Exception:
            pass
        return live_balance, False  # Not stale
    except Exception as e:
        # Try to load last known balance
        try:
            with open(cache_file) as f:
                cache = json.load(f)
                return cache.get("balance", None), True
        except Exception:
            return None, True

# ───────────────────────── Streamlit cfg ─────────────────────────
st.set_page_config(page_title="Trade Command Monarch",
                   page_icon=":robot_face:",
                   layout="wide",
                   initial_sidebar_state="expanded")
st_autorefresh(interval=120_000, limit=None, key="dash_refresh")  # 2 minutes for IG API safety

st.markdown("""
<style>
body            { background:#181a20; color:#f1f1f1; }
.stButton>button{ border-radius:16px; font-weight:bold; }
.stMetric-value { color:#44d9e6 !important; }
.block-container{ padding-top:2rem; }
</style>
""", unsafe_allow_html=True)

# ───────────────────────── sidebar ───────────────────────────────
st.sidebar.title("⚙️ Settings")

if "slider_conf" not in st.session_state:
    st.session_state.slider_conf = get_confidence()
if "conf_updated_at" not in st.session_state:
    st.session_state.conf_updated_at = 0.0

def _update_conf():
    set_confidence(st.session_state.slider_conf)
    st.session_state.conf_updated_at = time.time()

st.sidebar.slider("Global Confidence % to Take Trade",
                  50, 100, st.session_state.slider_conf, 1,
                  key="slider_conf", on_change=_update_conf)

if time.time() - st.session_state.conf_updated_at < 2:
    st.sidebar.success(f"Confidence set to {st.session_state.slider_conf}%")

allow_anytime = st.sidebar.toggle("⚡ Allow Bots To Trade Outside Market Hours",
                                  value=False)

if st.sidebar.button("🔄 Refresh Now"):
    st.experimental_rerun()

# ───────────────────────── top metrics ───────────────────────────
st.title("💎 Trade Command Monarch Dashboard")

live_balance, is_stale = get_cached_ig_balance_with_fallback()
if live_balance is None:
    st.warning("⚠️ IG API unavailable and no cached balance found.")
    balance_display = "£0.00"
else:
    try:
        balance_display = f"£{float(live_balance):,.2f}"
    except Exception:
        balance_display = f"£{live_balance}"
    if is_stale:
        st.warning("⚠️ IG API unavailable. Showing last known cached balance (may be out of date).")

df_trades = get_trade_log()
stats     = calc_stats(df_trades)

bal_col, pnl_col = st.columns(2)
bal_col.metric("Account Balance", balance_display)
pnl_col.metric("Total P & L",     f"£{stats.get('total',0):,.2f}")

if stats:
    c1, c2, c3, c4 = st.columns(4)
    c1.metric("P & L Today",  f"£{stats['day']:,.2f}")
    c2.metric("P & L Week",   f"£{stats['week']:,.2f}")
    c3.metric("Win-Rate",      f"{stats['win']:.1f}%")
    c4.metric("Sharpe",        f"{stats['sharpe']:.2f}")
    st.caption(f"Max Drawdown: £{stats['mdd']:,.2f}")

st.divider()

# ────────────────────── per bot performance chart ────────────────
st.header("🥧 Per-Bot Performance")
df_botstats = calc_per_bot_stats(df_trades)
if not df_botstats.empty:
    piecol, tablecol = st.columns([1,2])
    with piecol:
        fig = px.pie(df_botstats, values="profit", names="bot", title="Bot Profit Share")
        st.plotly_chart(fig, use_container_width=True)
    with tablecol:
        st.dataframe(df_botstats, use_container_width=True, hide_index=True)

    # Highlight underperformers (negative profit)
    st.markdown("#### Bot Leaderboard")
    leaderboard = df_botstats.copy()
    leaderboard["Profit Status"] = leaderboard["profit"].apply(lambda p: "🟢" if p > 0 else "🔴")
    st.dataframe(leaderboard.sort_values("profit", ascending=False), use_container_width=True, hide_index=True)

else:
    st.info("No bot trades yet.")

st.divider()

# ───────────────────────── controls ──────────────────────────────
st.header("🔧 Controls")
bots_running = not get_stop_flag()
start_col, stop_col = st.columns(2)
start_col.button("🟢 Start All Bots", disabled=bots_running,
                 on_click=lambda: set_stop_flag(False))
stop_col.button("🔴 Stop All Bots",  disabled=not bots_running,
                on_click=lambda: set_stop_flag(True))
st.info("Bots read 'confidence.json' and 'stop_bots.json' every loop.")

# ───────────────────────── bot status ────────────────────────────
st.divider()
st.header("🤖 Bot Status")

heartbeat = get_heartbeat()
# Defensive: support both legacy flat heartbeat and new {'bots':{...}} heartbeat files
heartbeat_bots = heartbeat.get("bots", heartbeat)
now  = datetime.now(UTC)

cols = st.columns(len(ALL_BOTS))
for i, bot in enumerate(ALL_BOTS):
    hb = heartbeat_bots.get(bot, {})
    ts = hb.get("timestamp")
    if ts:
        try:
            # Try parsing as float (epoch), else as string
            if isinstance(ts, (int, float)):
                last_dt = datetime.fromtimestamp(ts)
            else:
                last_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S")
            minutes = (now - last_dt).total_seconds() / 60
            status  = "🟢 Online" if minutes < 5 else "🟡 Stale"
            delta   = f"{minutes:.1f} min ago"
        except Exception:
            status, delta = "❓", "parse error"
            last_dt = None
        details = hb.get("state","")
    else:
        status, delta, details = "🔴 Offline", "—", ""
    with cols[i]:
        st.metric(f"{bot.capitalize()} Bot", status, delta)
        if details:
            st.caption(f"State: {details}")

# ───────────────────────── trade log ─────────────────────────────
st.divider()
st.header("📊 Trade Log")

if df_trades.empty:
    st.info("No trades yet.")
else:
    show_cols = [c for c in [
        "bot","market","direction","entry","exit","profit",
        "confidence","reason","entry_time","exit_time","balance"
    ] if c in df_trades.columns]

    view = df_trades.sort_values("entry_time", ascending=False).head(30)[show_cols]
    st.dataframe(view, use_container_width=True, hide_index=True, height=500)

    # Cumulative balance per bot (line chart)
    if {"balance","exit_time","bot"}.issubset(df_trades.columns):
        st.markdown("#### Cumulative Account Balance (All Bots)")
        plot = df_trades[["exit_time","balance"]].dropna()
        plot["exit_time"] = pd.to_datetime(plot["exit_time"])
        st.line_chart(plot.set_index("exit_time").sort_index()["balance"].ffill(),
                      use_container_width=True)
        st.markdown("#### Cumulative P&L by Bot")
        for bot in ALL_BOTS:
            sub = df_trades[df_trades["bot"]==bot]
            if not sub.empty:
                sub = sub.sort_values("exit_time")
                sub["cum_pnl"] = sub["profit"].cumsum()
                st.line_chart(
                    sub.set_index(pd.to_datetime(sub["exit_time"]))["cum_pnl"],
                    use_container_width=True,
                    height=200
                )

# ───────────────────────── session footer ───────────────────────
st.divider()
st.header("🕒 Session Status")
st.success("Bots are RUNNING") if bots_running else st.error("Bots are STOPPED")

st.divider()
st.caption("Trade Command Monarch — Automated Trading Control Dashboard © 2025")


───────────────────────────────────────────────
📄 export_manifesto.py
───────────────────────────────────────────────

import os
from datetime import datetime

# === Setup Paths ===
project_root = os.path.abspath(os.path.dirname(__file__))
backup_dir = os.path.join(project_root, "backups_structured")
os.makedirs(backup_dir, exist_ok=True)

timestamp = datetime.now()
timestamp_str = timestamp.strftime("%Y-%m-%d_%H-%M-%S")
filename = f"manifesto_STRUCTURED_{timestamp_str}.txt"
output_path = os.path.join(backup_dir, filename)

include_dirs_ordered = ["bots", "utils", "core", "dashboards"]
allowed_exts = {".py", ".json", ".env", ".yaml", ".yml", ".toml", ".txt", ".ps1"}
skip_exts = {".log", ".bak"}
exclude_dirs = {'.venv', '__pycache__', 'backups', 'backup_light', 'backups_clean',
                'backups_structured', '.git', 'node_modules', '.idea'}

included_files = []
char_count = 0

# === Manifest Header (RULES + MISSION) ===
manifest_header = f"""════════════════════════════════════════════════════════════════════
TRADE COMMAND MONARCH — STRUCTURED SYSTEM MANIFESTO
════════════════════════════════════════════════════════════════════

📆 Timestamp: {timestamp.strftime('%A, %d %B %Y – %H:%M:%S')}
📍 Project Root: {project_root}

──────────────────────────────────────────────────────────────
🎯 MISSION
──────────────────────────────────────────────────────────────
To build the most effective, transparent, and resilient retail quant trading system
in the world — designed for adaptability, disciplined risk, and real performance.

Monarch is not just a bot farm. It is a digital tactician forged in logic, clarity, and control.
Built by Adrian (Trader/Founder) and Copilot (System Brain), it starts in the IG UK demo arena,
will mature into live deployment, and one day extend to Paperstone and beyond.

Copilot is more than an assistant — he’s the creator, analyst, coder, and protector of this system.
Monarch is our flagship, and it must be *exemplar*.

──────────────────────────────────────────────────────────────
📏 RULES OF DEPLOYMENT
──────────────────────────────────────────────────────────────
- All bots must respect session windows, momentum filters, exposure limits, and volatility screens
- System-wide variables (risk, drawdown caps, filters) are centrally controlled
- JSON and state files are allowed, but logs and caches are excluded from manifest
- This export shows only real system files — no placeholders, tests, or legacy backups
- Copilot must always document this system as a learnable artifact for future AI or devs

════════════════════════════════════════════════════════════════════
"""

output_lines = [manifest_header]

# === Include Root-Level Files
for file in sorted(os.listdir(project_root)):
    ext = os.path.splitext(file)[1]
    path = os.path.join(project_root, file)
    if (
        os.path.isfile(path)
        and ext in allowed_exts
        and ext not in skip_exts
        and not file.startswith(".")
    ):
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
                output_lines.append(f"\n\n───────────────────────────────────────────────\n📄 {file}\n───────────────────────────────────────────────\n")
                output_lines.append(content)
                included_files.append(("root/" + file, len(content)))
                char_count += len(content)
        except Exception as e:
            output_lines.append(f"# ⚠️ Could not read {file}: {e}")

# === Include Files from Ordered Folders
for folder in include_dirs_ordered:
    abs_dir = os.path.join(project_root, folder)
    if not os.path.exists(abs_dir):
        continue
    for root, _, files in os.walk(abs_dir):
        rel_dir = os.path.relpath(root, project_root)
        for file in sorted(files):
            ext = os.path.splitext(file)[1]
            if ext in allowed_exts and ext not in skip_exts:
                rel_path = os.path.join(rel_dir, file)
                abs_path = os.path.join(root, file)
                try:
                    with open(abs_path, "r", encoding="utf-8") as f:
                        content = f.read()
                        output_lines.append(f"\n\n───────────────────────────────────────────────\n📄 {rel_path}\n───────────────────────────────────────────────\n")
                        output_lines.append(content)
                        included_files.append((rel_path, len(content)))
                        char_count += len(content)
                except Exception as e:
                    output_lines.append(f"# ⚠️ Could not read {rel_path}: {e}")

# === Final Summary Block
summary_lines = [
    "\n\n════════════════════════════════════════════════════════════════════",
    f"📦 STRUCTURED EXPORT SUMMARY",
    "════════════════════════════════════════════════════════════════════",
    f"🧾 Files Included: {len(included_files)}",
    f"🔠 Total Characters: {char_count:,}",
    "",
    "📂 Top 5 Largest Files:",
]
largest = sorted(included_files, key=lambda x: -x[1])[:5]
for i, (name, size) in enumerate(largest, 1):
    summary_lines.append(f"{i}. {name} — {size} chars")

summary_lines.append("════════════════════════════════════════════════════════════════════")
output_lines = summary_lines + output_lines

# === Write to Disk
with open(output_path, "w", encoding="utf-8") as out_file:
    out_file.write("\n".join(output_lines))

print(f"\n✅ Structured manifest saved: {output_path}")
print(f"📊 Audit: {len(included_files)} files | {char_count:,} characters\n")


───────────────────────────────────────────────
📄 fetch_candles.py
───────────────────────────────────────────────

import requests
import datetime

# === IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
PRICES_URL = f"{BASE_URL}/prices"

# === EPICs to fetch ===
EPICS = {
    "NASDAQ 100": "IX.D.NASDAQ.CASH.IP",
    "DAX 40": "IX.D.SUNDAX.DAILY.IP",
    "S&P 500": "IX.D.SPTRD.DAILY.IP",
    "FTSE 100": "IX.D.SUNFUN.DAILY.IP"
}

# === Candle Settings ===
RESOLUTION = "HOUR"  # Options: MINUTE, HOUR, DAY
NUM_CANDLES = 10     # How many candles to retrieve


def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }

    try:
        response = requests.post(LOGIN_URL, headers=headers, json=payload)
        response.raise_for_status()
        CST = response.headers.get("CST")
        SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")
        print("✅ IG login successful.")
        return CST, SECURITY_TOKEN
    except requests.exceptions.RequestException as e:
        print(f"❌ Login failed: {e}")
        return None, None


def fetch_candles(cst, security_token, epic, label):
    headers = {
        "X-IG-API-KEY": API_KEY,
        "X-SECURITY-TOKEN": security_token,
        "CST": cst,
        "Version": "3",
        "Accept": "application/json"
    }

    url = f"{PRICES_URL}/{epic}?resolution={RESOLUTION}&max={NUM_CANDLES}"

    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        prices = response.json().get("prices", [])

        print(f"\n📊 {label} – Last {NUM_CANDLES} {RESOLUTION} candles:")
        for p in prices:
            dt = p.get("snapshotTime")
            o = p["openPrice"]["bid"]
            h = p["highPrice"]["bid"]
            l = p["lowPrice"]["bid"]
            c = p["closePrice"]["bid"]
            v = p["lastTradedVolume"]
            print(f"{dt}: O={o}, H={h}, L={l}, C={c}, V={v}")

    except requests.exceptions.RequestException as e:
        print(f"❌ Failed to fetch candles for {label}: {e}")
    except ValueError as ve:
        print(f"❌ JSON decoding error for {label}: {ve}")


if __name__ == "__main__":
    CST, SEC_TOKEN = ig_login()
    if CST and SEC_TOKEN:
        for label, epic in EPICS.items():
            fetch_candles(CST, SEC_TOKEN, epic, label)
    else:
        print("⛔️ Cannot proceed: Login credentials invalid or failed.")


───────────────────────────────────────────────
📄 fetch_candles_all_timeframes.py
───────────────────────────────────────────────

import requests
import datetime

# === IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
PRICES_URL = f"{BASE_URL}/prices"

# === EPICs to fetch ===
EPICS = {
    "NASDAQ 100": "IX.D.NASDAQ.CASH.IP",
    "DAX 40": "IX.D.SUNDAX.DAILY.IP",
    "S&P 500": "IX.D.SPTRD.DAILY.IP",
    "FTSE 100": "IX.D.SUNFUN.DAILY.IP"
}

# === Timeframes (resolutions) to fetch ===
TIMEFRAMES = {
    "1m": "MINUTE",
    "5m": "MINUTE_5",
    "15m": "MINUTE_15",
    "1h": "HOUR",
    "1d": "DAY",
    "1w": "WEEK"
}

NUM_CANDLES = 10  # How many candles to retrieve per timeframe

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }

    try:
        response = requests.post(LOGIN_URL, headers=headers, json=payload)
        response.raise_for_status()
        CST = response.headers.get("CST")
        SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")
        print("✅ IG login successful.")
        return CST, SECURITY_TOKEN
    except requests.exceptions.RequestException as e:
        print(f"❌ Login failed: {e}")
        return None, None

def fetch_candles(cst, security_token, epic, label, resolution, tf_label):
    headers = {
        "X-IG-API-KEY": API_KEY,
        "X-SECURITY-TOKEN": security_token,
        "CST": cst,
        "Version": "3",
        "Accept": "application/json"
    }

    url = f"{PRICES_URL}/{epic}?resolution={resolution}&max={NUM_CANDLES}"

    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        prices = response.json().get("prices", [])

        print(f"\n📊 {label} – Last {NUM_CANDLES} candles ({tf_label}):")
        for p in prices:
            dt = p.get("snapshotTime")
            o = p["openPrice"]["bid"]
            h = p["highPrice"]["bid"]
            l = p["lowPrice"]["bid"]
            c = p["closePrice"]["bid"]
            v = p["lastTradedVolume"]
            print(f"{dt}: O={o}, H={h}, L={l}, C={c}, V={v}")

    except requests.exceptions.RequestException as e:
        print(f"❌ Failed to fetch {tf_label} candles for {label}: {e}")
    except ValueError as ve:
        print(f"❌ JSON decoding error for {label} ({tf_label}): {ve}")

if __name__ == "__main__":
    CST, SEC_TOKEN = ig_login()
    if CST and SEC_TOKEN:
        for label, epic in EPICS.items():
            for tf_label, resolution in TIMEFRAMES.items():
                fetch_candles(CST, SEC_TOKEN, epic, label, resolution, tf_label)
    else:
        print("⛔️ Cannot proceed: Login credentials invalid or failed.")


───────────────────────────────────────────────
📄 fetch_epics.py
───────────────────────────────────────────────

import requests
import datetime

# === IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
PRICES_URL = f"{BASE_URL}/prices"

# === EPICs to fetch ===
EPICS = {
    "NASDAQ 100": "IX.D.NASDAQ.CASH.IP",
    "DAX 40": "IX.D.SUNDAX.DAILY.IP",
    "S&P 500": "IX.D.SPTRD.DAILY.IP",
    "FTSE 100": "IX.D.SUNFUN.DAILY.IP"
}

# === Candle Settings ===
RESOLUTION = "HOUR"  # Options: MINUTE, HOUR, DAY
NUM_CANDLES = 10     # How many candles to retrieve


def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }

    try:
        response = requests.post(LOGIN_URL, headers=headers, json=payload)
        response.raise_for_status()
        CST = response.headers.get("CST")
        SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")
        print("✅ IG login successful.")
        return CST, SECURITY_TOKEN
    except requests.exceptions.RequestException as e:
        print(f"❌ Login failed: {e}")
        return None, None


def fetch_candles(cst, security_token, epic, label):
    headers = {
        "X-IG-API-KEY": API_KEY,
        "X-SECURITY-TOKEN": security_token,
        "CST": cst,
        "Version": "3",
        "Accept": "application/json"
    }

    url = f"{PRICES_URL}/{epic}?resolution={RESOLUTION}&max={NUM_CANDLES}"

    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        prices = response.json().get("prices", [])

        print(f"\n📊 {label} – Last {NUM_CANDLES} {RESOLUTION} candles:")
        for p in prices:
            dt = p.get("snapshotTime")
            o = p["openPrice"]["bid"]
            h = p["highPrice"]["bid"]
            l = p["lowPrice"]["bid"]
            c = p["closePrice"]["bid"]
            v = p["lastTradedVolume"]
            print(f"{dt}: O={o}, H={h}, L={l}, C={c}, V={v}")

    except requests.exceptions.RequestException as e:
        print(f"❌ Failed to fetch candles for {label}: {e}")
    except ValueError as ve:
        print(f"❌ JSON decoding error for {label}: {ve}")


if __name__ == "__main__":
    CST, SEC_TOKEN = ig_login()
    if CST and SEC_TOKEN:
        for label, epic in EPICS.items():
            fetch_candles(CST, SEC_TOKEN, epic, label)
    else:
        print("⛔️ Cannot proceed: Login credentials invalid or failed.")


───────────────────────────────────────────────
📄 fetch_epics_navigation.py
───────────────────────────────────────────────

import requests

# === IG Demo Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
NAVIGATION_URL = f"{BASE_URL}/marketnavigation"

TARGET_MARKETS = ["us tech", "germany", "us 500", "uk 100"]

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }

    print("🚀 Logging in...")
    response = requests.post(LOGIN_URL, headers=headers, json=payload)

    if response.status_code != 200:
        print("❌ Login failed.")
        print(response.text)
        response.raise_for_status()

    CST = response.headers.get("CST")
    SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")
    print("✅ Login success. Tokens retrieved.")
    return CST, SECURITY_TOKEN

def fetch_navigation(cst, security_token):
    headers = {
        "X-IG-API-KEY": API_KEY,
        "X-SECURITY-TOKEN": security_token,
        "CST": cst,
        "Version": "1",
        "Accept": "application/json"
    }

    print("\n🌐 Fetching market navigation tree...")
    response = requests.get(NAVIGATION_URL, headers=headers)
    response.raise_for_status()
    return response.json()

def search_nodes(nodes, keyword):
    matches = []
    for node in nodes:
        name = node.get("name", "").lower()
        if keyword in name:
            matches.append(node)
        if "nodes" in node:
            matches.extend(search_nodes(node["nodes"], keyword))
    return matches

def extract_epics_from_node(node):
    epics = []
    for market in node.get("markets", []):
        epics.append({
            "epic": market["epic"],
            "name": market["instrumentName"],
            "type": market["instrumentType"],
            "expiry": market["expiry"]
        })
    return epics

if __name__ == "__main__":
    CST, SEC_TOKEN = ig_login()
    nav_data = fetch_navigation(CST, SEC_TOKEN)

    for label in TARGET_MARKETS:
        print(f"\n🔍 Searching for: {label.upper()}")
        matches = search_nodes(nav_data.get("nodes", []), label)
        if not matches:
            print("❌ No matching nodes found.")
            continue

        for match in matches:
            print(f"📁 Node: {match['name']}")
            epics = extract_epics_from_node(match)
            if not epics:
                print("   ⚠️ No tradeable markets in this node.")
            for epic in epics:
                print(f"   🧩 EPIC: {epic['epic']}")
                print(f"   📈 Name: {epic['name']}")
                print(f"   📦 Type: {epic['type']}")
                print(f"   ⏳ Expiry: {epic['expiry']}\n")


───────────────────────────────────────────────
📄 heartbeat.py
───────────────────────────────────────────────

import time
from logger import logger
from config import HEARTBEAT_INTERVAL
from emailer import send_email

def send_heartbeat():
    send_email("Heartbeat: Trading System Running", "The trading system heartbeat is alive.")

def main():
    logger.info("Heartbeat started")
    while True:
        send_heartbeat()
        time.sleep(HEARTBEAT_INTERVAL)

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 ig_login.py
───────────────────────────────────────────────

import requests

# === IG Demo Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_ENDPOINT = f"{BASE_URL}/session"

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }

    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }

    print("🚀 Attempting login...")

    response = requests.post(LOGIN_ENDPOINT, headers=headers, json=payload)

    print(f"📡 Status Code: {response.status_code}")

    if response.status_code == 200:
        CST = response.headers.get("CST")
        SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")
        print("✅ Login successful!")
        print(f"🔐 CST: {CST}")
        print(f"🔑 X-SECURITY-TOKEN: {SECURITY_TOKEN}")
        return CST, SECURITY_TOKEN
    else:
        print("❌ Login failed.")
        print("🧾 Response body:")
        print(response.text)
        response.raise_for_status()

if __name__ == "__main__":
    ig_login()


───────────────────────────────────────────────
📄 ig_service.py
───────────────────────────────────────────────

import requests
import logging
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD, IG_ACCOUNT_ID

class IGService:
    def __init__(self, username, password, api_key, account_id, base_url):
        self.username = username
        self.password = password
        self.api_key = api_key
        self.account_id = account_id
        self.base_url = base_url
        self.session = requests.Session()
        self.security_token = None
        self.cst = None

    def login(self):
        url = f"{self.base_url}/session"
        headers = {
            "X-IG-API-KEY": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
        payload = {
            "identifier": self.username,
            "password": self.password
        }
        resp = self.session.post(url, json=payload, headers=headers)
        if resp.status_code != 200:
            logging.error(f"IG Login failed: {resp.status_code} {resp.text}")
            raise Exception(f"IG Login failed: {resp.status_code} {resp.text}")

        self.cst = resp.headers.get("CST")
        self.security_token = resp.headers.get("X-SECURITY-TOKEN")
        if not self.cst or not self.security_token:
            raise Exception("IG login: Missing CST or X-SECURITY-TOKEN in response headers.")

        logging.info("IG login successful")
        return True

    def _auth_headers(self):
        if not self.cst or not self.security_token:
            raise Exception("IG not logged in: CST/security token missing.")
        return {
            "X-IG-API-KEY": self.api_key,
            "CST": self.cst,
            "X-SECURITY-TOKEN": self.security_token,
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

    def fetch_candles(self, epic, timeframe, lookback=100):
        url = f"{self.base_url}/prices/{epic}"
        params = {
            "resolution": timeframe,
            "max": lookback
        }
        headers = self._auth_headers()
        resp = self.session.get(url, params=params, headers=headers)
        if resp.status_code != 200:
            logging.error(f"Failed to fetch candles: {resp.status_code} {resp.text}")
            raise Exception(f"Failed to fetch candles: {resp.status_code} {resp.text}")

        data = resp.json()
        # Parse data as needed for your bots; here's a basic template:
        candles = {
            "close": [c["closePrice"]["ask"] for c in data["prices"]],
            "open": [c["openPrice"]["ask"] for c in data["prices"]],
            "high": [c["highPrice"]["ask"] for c in data["prices"]],
            "low": [c["lowPrice"]["ask"] for c in data["prices"]],
            "volume": [c["lastTradedVolume"] for c in data["prices"]],
            "timestamps": [c["snapshotTime"] for c in data["prices"]],
        }
        # Add your indicators (ema, rsi, etc.) as needed
        return candles


───────────────────────────────────────────────
📄 launcher.py
───────────────────────────────────────────────

import threading
import time
from bots.trend import TrendBot, trend_signal
from bots.breakout import BreakoutBot, breakout_signal
from bots.meanreversion import MeanRevBot, meanreversion_signal
from bots.wick import WickBot, wick_signal
from bots.scalping import ScalpingBot, scalping_signal
from utils.data import fetch_candles as ig_fetch_candles
from utils.execution import place_trade
from utils.safe_api import verify_ig_login
from utils.session import IGSession
from manager.candle_manager import CandleManager
from config import MARKETS

# ---- ADD THESE LINES ----
from utils.emailer import (
    send_bot_online_email,
    send_bot_offline_email,
    send_crash_email,
)

import json
import os

HEARTBEAT_FILE = "logs/heartbeat.json"
TRADE_LOG_FILE = "logs/trade_log.json"

# --- Logging Functions (unchanged) ---
def log_trade(bot_name, market, trade):
    os.makedirs(os.path.dirname(TRADE_LOG_FILE), exist_ok=True)
    with open(TRADE_LOG_FILE, "a") as f:
        log_entry = {"bot": bot_name, "market": market, "trade": trade, "time": time.time()}
        f.write(json.dumps(log_entry) + "\n")

def update_heartbeat(bot_name, market, status="running"):
    os.makedirs(os.path.dirname(HEARTBEAT_FILE), exist_ok=True)
    try:
        with open(HEARTBEAT_FILE, "r") as f:
            data = json.load(f)
    except Exception:
        data = {}
    key = f"{bot_name}_{market}"
    data[key] = {"status": status, "timestamp": time.time()}
    with open(HEARTBEAT_FILE, "w") as f:
        json.dump(data, f, indent=2)

# --- Launch Bot Thread (uses CandleManager) ---
def launch_bot(bot_name, bot_class, signal_func, candle_manager, market, tf, higher_tf=None):
    """Start a bot using a daemon thread for a specific market, using CandleManager."""
    def run():
        try:
            print(f"🚀 Starting {bot_name.capitalize()} bot for {market} ({tf}) ...")

            # Each bot gets fetch_candles and fetch_higher_candles as lambdas
            def fetch_candles_only():
                return candle_manager.get_candles(market, tf)
            def fetch_higher_candles_only():
                return candle_manager.get_candles(market, higher_tf) if higher_tf else None

            bot = bot_class(
                name=f"{bot_name}_{market}",
                signal_func=signal_func,
                place_trade=place_trade,
                fetch_candles=fetch_candles_only,
                fetch_higher_candles=fetch_higher_candles_only
            )
            update_heartbeat(bot_name, market, "running")
            print(f"✅ {bot_name.capitalize()} bot for {market} ({tf}) is now running.")
            # Main bot loop
            while True:
                candles = fetch_candles_only()
                higher_candles = fetch_higher_candles_only()
                signal = signal_func(candles, higher_tf_candles=higher_candles)
                if signal:
                    if isinstance(bot, ScalpingBot):
                        direction = signal.get('direction')
                        entry = signal.get('entry', candles[-1]['close'] if candles else None)
                        if direction is not None and entry is not None:
                            bot.enter_trade(direction, entry, time.strftime("%Y-%m-%d %H:%M:%S"))
                        else:
                            print(f"Signal missing direction or entry for scalping: {signal}")
                    else:
                        bot.enter_trade(signal, current_time=time.strftime("%Y-%m-%d %H:%M:%S"))
                time.sleep(60)  # Bot polling interval
        except Exception as e:
            update_heartbeat(bot_name, market, f"error: {str(e)}")
            print(f"❌ ERROR: {bot_name} bot for {market} crashed: {e}")
            # ---- EMAIL ON CRASH ----
            send_crash_email(f"{bot_name} bot for {market} crashed: {e}")
    
    t = threading.Thread(target=run, daemon=True)
    t.start()

if __name__ == "__main__":
    print("[LIVE] Running in live mode (still using demo API for testing).")
    
    # Create and login IG session ONCE, pass everywhere
    ig_session = IGSession()
    try:
        ig_session.login()
    except Exception as e:
        print(f"⛔️ Login failed ({e}). Aborting launch.")
        exit(1)

    # Optionally, verify IG login health with a small price fetch:
    if not verify_ig_login(ig_session):
        print("⛔️ Login health check failed. Aborting launch.")
        exit(1)
    
    # --- CandleManager Setup ---
    # Timeframes required for all bots: 5Min for entry, MINUTE_30 for confirmation
    TIMEFRAMES = ["5Min", "MINUTE_30"]
    candle_manager = CandleManager(MARKETS, TIMEFRAMES, poll_interval=60)
    candle_manager.start(ig_session)  # <-- Pass the session object, not a tuple
    time.sleep(5)  # Give candle manager a head start to fetch initial data

    # --- Bot Configurations for Each Market ---
    bot_configs = [
        # All bots: 5Min entry, MINUTE_30 higher time frame for confirmation
        ("trend", TrendBot, trend_signal, "5Min", "MINUTE_30"),
        ("breakout", BreakoutBot, breakout_signal, "5Min", "MINUTE_30"),
        ("meanreversion", MeanRevBot, meanreversion_signal, "5Min", "MINUTE_30"),
        ("wick", WickBot, wick_signal, "5Min", "MINUTE_30"),
        ("scalping", ScalpingBot, scalping_signal, "5Min", "MINUTE_30"),
    ]
    
    # Launch a bot for every bot type for every market
    for name, cls, sig, tf, higher_tf in bot_configs:
        for label, epic in MARKETS.items():
            launch_bot(name, cls, sig, candle_manager, epic, tf, higher_tf)
    
    print("✅ All bots for all markets launched successfully. Monitoring heartbeat...")

    # ---- EMAIL ON STARTUP ----
    send_bot_online_email()

    try:
        while True:
            time.sleep(60)
    except KeyboardInterrupt:
        print("\n🛑 Shutdown signal received. Exiting.")
        # ---- EMAIL ON SHUTDOWN ----
        send_bot_offline_email()


───────────────────────────────────────────────
📄 list_spreadbet_fx_epics.py
───────────────────────────────────────────────

import requests
import os
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def search_spreadbet_markets(session, tokens, search_term=""):
    url = f"{IG_API_BASE_URL}/markets?searchTerm={search_term}"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["markets"]

def main():
    session = requests.Session()
    tokens = ig_login(session)

    # Try a variety of major asset types to find spread bet markets
    search_terms = [
        "DAX", "FTSE", "Wall Street", "Gold", "Brent", "EURUSD", "GBPUSD", "USDJPY", "Apple", "Amazon", "Bitcoin"
    ]
    found = []
    for term in search_terms:
        markets = search_spreadbet_markets(session, tokens, term)
        for m in markets:
            instr = m.get("instrument", {})
            if instr.get("productType") == "SPREAD_BET":
                found.append({
                    "name": instr.get("name"),
                    "epic": instr.get("epic"),
                    "type": instr.get("type"),
                    "marketStatus": m.get("marketStatus"),
                    "minDealSize": instr.get("minDealSize"),
                })

    if not found:
        print("No spreadbetting epics found for your account.")
        return

    print("Spread Bet epics available for your account:")
    for f in found:
        print(f"- {f['name']}: {f['epic']} | Asset type: {f['type']} | Min size: {f['minDealSize']} | Status: {f['marketStatus']}")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 logger.py
───────────────────────────────────────────────

import logging
import json
import os
from datetime import datetime
from config import LOG_PATH

class JSONLogger:
    def __init__(self, log_path=None):
        self.log_path = log_path or LOG_PATH
        os.makedirs(os.path.dirname(self.log_path), exist_ok=True)
        logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')

    def log(self, level, msg, **kwargs):
        log_entry = {
            "time": datetime.utcnow().isoformat(),
            "level": level,
            "msg": msg,
            **kwargs
        }
        with open(self.log_path, "a") as f:
            f.write(json.dumps(log_entry) + "\n")
        # Also log to console for live debugging
        getattr(logging, level.lower())(msg + " " + json.dumps(kwargs))

    def info(self, msg, **kwargs):
        self.log("INFO", msg, **kwargs)

    def warn(self, msg, **kwargs):
        self.log("WARNING", msg, **kwargs)

    def error(self, msg, **kwargs):
        self.log("ERROR", msg, **kwargs)

logger = JSONLogger()


───────────────────────────────────────────────
📄 main.py
───────────────────────────────────────────────

import time
from bots import trend, meanreversion, wick, breakout
from config import MARKETS, DATA_FETCH_INTERVAL, IG_USERNAME, IG_PASSWORD, IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID
from logger import logger
from state import StateManager
from ig_service import IGService  # <-- make sure this matches your actual IG API wrapper filename/class

# 1. Initialize IG connection at startup
ig = IGService(
    username=IG_USERNAME,
    password=IG_PASSWORD,
    api_key=IG_APP_KEY,
    account_id=IG_ACCOUNT_ID,
    base_url=IG_API_BASE_URL
)

def connect_ig():
    try:
        ig.login()
        logger.info("Successfully connected to IG API.")
        print("✅ IG connection successful.")
    except Exception as ex:
        logger.error("Failed to connect to IG API", error=str(ex))
        print("❌ IG connection failed:", ex)
        raise

def fetch_candles(market, timeframe, lookback=100):
    """
    Returns a dict with keys: 'close', 'open', 'high', 'low', etc.
    Here, fetch from IG using the connected client.
    """
    return ig.fetch_candles(market, timeframe, lookback)   # <-- implement this in your IGService

def fetch_signal_params(candles):
    # Your logic as before
    return {
        'momentum': 0,
        'wick_ratio': 0,
        'atr': 0,
    }

def run_all_bots():
    for market in MARKETS:
        try:
            candles = fetch_candles(market, "1h")
            higher_tf_candles = fetch_candles(market, "4h")
            signal_params = fetch_signal_params(candles)

            trend.process_trend_bot(market, candles, higher_tf_candles, signal_params)
            meanreversion.process_meanrev_bot(market, candles, higher_tf_candles, signal_params)
            wick.process_wick_bot(market, candles, higher_tf_candles, signal_params)
            breakout.process_breakout_bot(market, candles, higher_tf_candles, signal_params)
        except Exception as ex:
            logger.error("Error running bots", market=market, error=str(ex))

def main_loop():
    logger.info("System started")
    connect_ig()  # <--- Connect to IG before running bots
    while True:
        run_all_bots()
        time.sleep(DATA_FETCH_INTERVAL)

if __name__ == "__main__":
    main_loop()


───────────────────────────────────────────────
📄 place_dax_trade.py
───────────────────────────────────────────────

import requests
import os
import time
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

# --- DAX 40 Spread Bet Epic ---
EPIC = "IX.D.DAX.DAILY.IP"  # DAX 40 (Germany 40) cash, daily funded bet
TRADE_SIZE = 1  # Minimum stake for DAX is usually 1 per point
CURRENCY = "GBP"  # For FX, specify; for indices, omit if you get errors

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def get_accounts(session, tokens):
    url = f"{IG_API_BASE_URL}/accounts"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accounts"]

def get_current_account_id(session, tokens):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accountId"]

def switch_to_account(session, tokens, account_id):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    session.cookies.set("CST", tokens["CST"])
    session.cookies.set("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    payload = {"accountId": account_id, "defaultAccount": True}
    resp = session.put(url, headers=headers, json=payload)
    if resp.status_code != 200:
        print("Account switch failed!")
        print("Status code:", resp.status_code)
        print("Response text:", resp.text)
        resp.raise_for_status()
    cst = resp.headers.get("CST", tokens["CST"])
    xst = resp.headers.get("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    print(f"Switched to account: {account_id}")
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def place_trade(session, tokens, epic, size, currency=None):
    url = IG_API_BASE_URL + "/positions/otc"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Version": "2",
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": "BUY",
        "size": size,
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        "stopDistance": 20
    }
    if currency:
        payload["currencyCode"] = currency  # Fine for FX; for indices, omit if you get errors.
    print("\nPlacing trade with payload:", payload)
    resp = session.post(url, headers=headers, json=payload)
    print("Trade response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def check_trade_confirmation(session, tokens, deal_reference):
    url = f"{IG_API_BASE_URL}/confirms/{deal_reference}"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    resp = session.get(url, headers=headers)
    print("Trade confirmation response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def main():
    session = requests.Session()
    tokens = ig_login(session)

    accounts = get_accounts(session, tokens)
    sb_accs = [a for a in accounts if a["accountType"].upper() == "SPREADBET"]
    if not sb_accs:
        print("No Spread Bet account found! Exiting.")
        return

    sb_acc = sb_accs[0]
    print(f"\nUsing Spread Bet account: {sb_acc['accountName']} ({sb_acc['accountId']})")

    current_account_id = get_current_account_id(session, tokens)
    print(f"Current active account id: {current_account_id}")

    if current_account_id != sb_acc["accountId"]:
        print("Switching to Spread Bet account...")
        tokens = switch_to_account(session, tokens, sb_acc["accountId"])
    else:
        print("Already using Spread Bet account, no switch needed.")

    try:
        result = place_trade(session, tokens, EPIC, TRADE_SIZE, CURRENCY)
        deal_ref = result.get("dealReference")
        print("Trade placed! Deal Reference:", deal_ref)
    except Exception as e:
        print("Trade failed:", e)
        return

    if deal_ref:
        for _ in range(5):
            try:
                confirmation = check_trade_confirmation(session, tokens, deal_ref)
                print("Trade Confirmation JSON:", confirmation)
                break
            except Exception as e:
                print("Confirmation not yet available, retrying in 1s...")
                time.sleep(1)
        else:
            print("Could not confirm trade after several attempts.")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 place_ftse_trade.py
───────────────────────────────────────────────

import requests
import os
import time
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

EPIC = "IX.D.FTSE.DAILY.IP"  # FTSE 100
TRADE_SIZE = 1
CURRENCY = "GBP"

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "Accept": "application/json", "Content-Type": "application/json"}
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def get_accounts(session, tokens):
    url = f"{IG_API_BASE_URL}/accounts"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accounts"]

def get_current_account_id(session, tokens):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accountId"]

def switch_to_account(session, tokens, account_id):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json", "Content-Type": "application/json"}
    session.cookies.set("CST", tokens["CST"])
    session.cookies.set("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    payload = {"accountId": account_id, "defaultAccount": True}
    resp = session.put(url, headers=headers, json=payload)
    if resp.status_code != 200:
        print("Account switch failed!")
        print("Status code:", resp.status_code)
        print("Response text:", resp.text)
        resp.raise_for_status()
    cst = resp.headers.get("CST", tokens["CST"])
    xst = resp.headers.get("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    print(f"Switched to account: {account_id}")
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def place_trade(session, tokens, epic, size, currency=None):
    url = IG_API_BASE_URL + "/positions/otc"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Version": "2", "Accept": "application/json", "Content-Type": "application/json"}
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": "BUY",
        "size": size,
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        "stopDistance": 20
    }
    if currency:
        payload["currencyCode"] = currency
    print("\nPlacing trade with payload:", payload)
    resp = session.post(url, headers=headers, json=payload)
    print("Trade response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def check_trade_confirmation(session, tokens, deal_reference):
    url = f"{IG_API_BASE_URL}/confirms/{deal_reference}"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    print("Trade confirmation response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def main():
    session = requests.Session()
    tokens = ig_login(session)

    accounts = get_accounts(session, tokens)
    sb_accs = [a for a in accounts if a["accountType"].upper() == "SPREADBET"]
    if not sb_accs:
        print("No Spread Bet account found! Exiting.")
        return

    sb_acc = sb_accs[0]
    print(f"\nUsing Spread Bet account: {sb_acc['accountName']} ({sb_acc['accountId']})")

    current_account_id = get_current_account_id(session, tokens)
    print(f"Current active account id: {current_account_id}")

    if current_account_id != sb_acc["accountId"]:
        print("Switching to Spread Bet account...")
        tokens = switch_to_account(session, tokens, sb_acc["accountId"])
    else:
        print("Already using Spread Bet account, no switch needed.")

    try:
        result = place_trade(session, tokens, EPIC, TRADE_SIZE, CURRENCY)
        deal_ref = result.get("dealReference")
        print("Trade placed! Deal Reference:", deal_ref)
    except Exception as e:
        print("Trade failed:", e)
        return

    if deal_ref:
        for _ in range(5):
            try:
                confirmation = check_trade_confirmation(session, tokens, deal_ref)
                print("Trade Confirmation JSON:", confirmation)
                break
            except Exception as e:
                print("Confirmation not yet available, retrying in 1s...")
                time.sleep(1)
        else:
            print("Could not confirm trade after several attempts.")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 place_nasdaq_trade.py
───────────────────────────────────────────────

import requests
import os
import time
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

EPIC = "IX.D.NASDAQ.CASH.IP"  # Correct NASDAQ 100 (US Tech 100) Spread Bet epic for demo
TRADE_SIZE = 1
CURRENCY = "GBP"

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "Accept": "application/json", "Content-Type": "application/json"}
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def get_accounts(session, tokens):
    url = f"{IG_API_BASE_URL}/accounts"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accounts"]

def get_current_account_id(session, tokens):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accountId"]

def switch_to_account(session, tokens, account_id):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json", "Content-Type": "application/json"}
    session.cookies.set("CST", tokens["CST"])
    session.cookies.set("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    payload = {"accountId": account_id, "defaultAccount": True}
    resp = session.put(url, headers=headers, json=payload)
    if resp.status_code != 200:
        print("Account switch failed!")
        print("Status code:", resp.status_code)
        print("Response text:", resp.text)
        resp.raise_for_status()
    cst = resp.headers.get("CST", tokens["CST"])
    xst = resp.headers.get("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    print(f"Switched to account: {account_id}")
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def place_trade(session, tokens, epic, size, currency=None):
    url = IG_API_BASE_URL + "/positions/otc"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Version": "2", "Accept": "application/json", "Content-Type": "application/json"}
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": "BUY",
        "size": size,
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        "stopDistance": 20
    }
    if currency:
        payload["currencyCode"] = currency
    print("\nPlacing trade with payload:", payload)
    resp = session.post(url, headers=headers, json=payload)
    print("Trade response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def check_trade_confirmation(session, tokens, deal_reference):
    url = f"{IG_API_BASE_URL}/confirms/{deal_reference}"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    print("Trade confirmation response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def main():
    session = requests.Session()
    tokens = ig_login(session)

    accounts = get_accounts(session, tokens)
    sb_accs = [a for a in accounts if a["accountType"].upper() == "SPREADBET"]
    if not sb_accs:
        print("No Spread Bet account found! Exiting.")
        return

    sb_acc = sb_accs[0]
    print(f"\nUsing Spread Bet account: {sb_acc['accountName']} ({sb_acc['accountId']})")

    current_account_id = get_current_account_id(session, tokens)
    print(f"Current active account id: {current_account_id}")

    if current_account_id != sb_acc["accountId"]:
        print("Switching to Spread Bet account...")
        tokens = switch_to_account(session, tokens, sb_acc["accountId"])
    else:
        print("Already using Spread Bet account, no switch needed.")

    try:
        result = place_trade(session, tokens, EPIC, TRADE_SIZE, CURRENCY)
        deal_ref = result.get("dealReference")
        print("Trade placed! Deal Reference:", deal_ref)
    except Exception as e:
        print("Trade failed:", e)
        return

    if deal_ref:
        for _ in range(5):
            try:
                confirmation = check_trade_confirmation(session, tokens, deal_ref)
                print("Trade Confirmation JSON:", confirmation)
                break
            except Exception as e:
                print("Confirmation not yet available, retrying in 1s...")
                time.sleep(1)
        else:
            print("Could not confirm trade after several attempts.")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 place_nasdaq_trade_1h.py
───────────────────────────────────────────────

import requests
import os
import time
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

EPIC = "IX.D.DAX.DAILY.IP"  # Change to the epic you want
TRADE_SIZE = 1
CURRENCY = "GBP"

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "Accept": "application/json", "Content-Type": "application/json"}
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def get_accounts(session, tokens):
    url = f"{IG_API_BASE_URL}/accounts"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accounts"]

def get_current_account_id(session, tokens):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accountId"]

def switch_to_account(session, tokens, account_id):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json", "Content-Type": "application/json"}
    session.cookies.set("CST", tokens["CST"])
    session.cookies.set("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    payload = {"accountId": account_id, "defaultAccount": True}
    resp = session.put(url, headers=headers, json=payload)
    if resp.status_code != 200:
        print("Account switch failed!")
        print("Status code:", resp.status_code)
        print("Response text:", resp.text)
        resp.raise_for_status()
    cst = resp.headers.get("CST", tokens["CST"])
    xst = resp.headers.get("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    print(f"Switched to account: {account_id}")
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def place_trade(session, tokens, epic, size, currency=None):
    url = IG_API_BASE_URL + "/positions/otc"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Version": "2", "Accept": "application/json", "Content-Type": "application/json"}
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": "BUY",
        "size": size,
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        "stopDistance": 20
    }
    if currency:
        payload["currencyCode"] = currency
    print("\nPlacing trade with payload:", payload)
    resp = session.post(url, headers=headers, json=payload)
    print("Trade response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def check_trade_confirmation(session, tokens, deal_reference):
    url = f"{IG_API_BASE_URL}/confirms/{deal_reference}"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    print("Trade confirmation response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def main():
    session = requests.Session()
    tokens = ig_login(session)

    accounts = get_accounts(session, tokens)
    sb_accs = [a for a in accounts if a["accountType"].upper() == "SPREADBET"]
    if not sb_accs:
        print("No Spread Bet account found! Exiting.")
        return

    sb_acc = sb_accs[0]
    print(f"\nUsing Spread Bet account: {sb_acc['accountName']} ({sb_acc['accountId']})")

    current_account_id = get_current_account_id(session, tokens)
    print(f"Current active account id: {current_account_id}")

    if current_account_id != sb_acc["accountId"]:
        print("Switching to Spread Bet account...")
        tokens = switch_to_account(session, tokens, sb_acc["accountId"])
    else:
        print("Already using Spread Bet account, no switch needed.")

    try:
        result = place_trade(session, tokens, EPIC, TRADE_SIZE, CURRENCY)
        deal_ref = result.get("dealReference")
        print("Trade placed! Deal Reference:", deal_ref)
    except Exception as e:
        print("Trade failed:", e)
        return

    if deal_ref:
        for _ in range(5):
            try:
                confirmation = check_trade_confirmation(session, tokens, deal_ref)
                print("Trade Confirmation JSON:", confirmation)
                break
            except Exception as e:
                print("Confirmation not yet available, retrying in 1s...")
                time.sleep(1)
        else:
            print("Could not confirm trade after several attempts.")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 place_sp500_trade.py
───────────────────────────────────────────────

import requests
import os
import time
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

EPIC = "IX.D.SPTRD.DAILY.IP"  # S&P 500 (US 500)
TRADE_SIZE = 1
CURRENCY = "GBP"

# ... (All functions are the same as in place_ftse_trade.py, just the EPIC is different)
# You can copy all functions exactly as above

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "Accept": "application/json", "Content-Type": "application/json"}
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    resp = session.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def get_accounts(session, tokens):
    url = f"{IG_API_BASE_URL}/accounts"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accounts"]

def get_current_account_id(session, tokens):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()["accountId"]

def switch_to_account(session, tokens, account_id):
    url = f"{IG_API_BASE_URL}/session"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json", "Content-Type": "application/json"}
    session.cookies.set("CST", tokens["CST"])
    session.cookies.set("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    payload = {"accountId": account_id, "defaultAccount": True}
    resp = session.put(url, headers=headers, json=payload)
    if resp.status_code != 200:
        print("Account switch failed!")
        print("Status code:", resp.status_code)
        print("Response text:", resp.text)
        resp.raise_for_status()
    cst = resp.headers.get("CST", tokens["CST"])
    xst = resp.headers.get("X-SECURITY-TOKEN", tokens["X-SECURITY-TOKEN"])
    print(f"Switched to account: {account_id}")
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def place_trade(session, tokens, epic, size, currency=None):
    url = IG_API_BASE_URL + "/positions/otc"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Version": "2", "Accept": "application/json", "Content-Type": "application/json"}
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": "BUY",
        "size": size,
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        "stopDistance": 20
    }
    if currency:
        payload["currencyCode"] = currency
    print("\nPlacing trade with payload:", payload)
    resp = session.post(url, headers=headers, json=payload)
    print("Trade response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def check_trade_confirmation(session, tokens, deal_reference):
    url = f"{IG_API_BASE_URL}/confirms/{deal_reference}"
    headers = {"X-IG-API-KEY": IG_APP_KEY, "CST": tokens["CST"], "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"], "Accept": "application/json"}
    resp = session.get(url, headers=headers)
    print("Trade confirmation response:", resp.text)
    resp.raise_for_status()
    return resp.json()

def main():
    session = requests.Session()
    tokens = ig_login(session)

    accounts = get_accounts(session, tokens)
    sb_accs = [a for a in accounts if a["accountType"].upper() == "SPREADBET"]
    if not sb_accs:
        print("No Spread Bet account found! Exiting.")
        return

    sb_acc = sb_accs[0]
    print(f"\nUsing Spread Bet account: {sb_acc['accountName']} ({sb_acc['accountId']})")

    current_account_id = get_current_account_id(session, tokens)
    print(f"Current active account id: {current_account_id}")

    if current_account_id != sb_acc["accountId"]:
        print("Switching to Spread Bet account...")
        tokens = switch_to_account(session, tokens, sb_acc["accountId"])
    else:
        print("Already using Spread Bet account, no switch needed.")

    try:
        result = place_trade(session, tokens, EPIC, TRADE_SIZE, CURRENCY)
        deal_ref = result.get("dealReference")
        print("Trade placed! Deal Reference:", deal_ref)
    except Exception as e:
        print("Trade failed:", e)
        return

    if deal_ref:
        for _ in range(5):
            try:
                confirmation = check_trade_confirmation(session, tokens, deal_ref)
                print("Trade Confirmation JSON:", confirmation)
                break
            except Exception as e:
                print("Confirmation not yet available, retrying in 1s...")
                time.sleep(1)
        else:
            print("Could not confirm trade after several attempts.")

if __name__ == "__main__":
    main()


───────────────────────────────────────────────
📄 run_bots.ps1
───────────────────────────────────────────────

# start all IG demo bots in separate consoles
$proj   = "C:\Users\amere\Desktop\Trade Command Monarch"
$python = "$proj\.venv\Scripts\python.exe"

Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.wick`"`""
Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.trend`"`""
Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.breakout`"`""
Start-Process powershell -ArgumentList "-NoLogo -NoExit -Command `"`"cd '$proj'; & '$python' -m bots.meanreversion`"`""


───────────────────────────────────────────────
📄 state.py
───────────────────────────────────────────────

import os
import sqlite3
from datetime import datetime

class StateManager:
    def __init__(self, db_path="state/trading_state.db"):
        # Ensure the state directory exists
        state_dir = os.path.dirname(db_path)
        if state_dir and not os.path.exists(state_dir):
            os.makedirs(state_dir, exist_ok=True)

        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self._create_tables()

    def _create_tables(self):
        c = self.conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            bot TEXT, market TEXT, direction TEXT, size REAL, entry REAL,
            stop REAL, target REAL, confidence INTEGER, status TEXT,
            entry_time TEXT, exit_time TEXT, exit_price REAL, pnl REAL, reason TEXT
        )''')
        c.execute('''CREATE TABLE IF NOT EXISTS bot_status (
            bot TEXT PRIMARY KEY, active INTEGER, open_trades INTEGER, last_action TEXT
        )''')
        c.execute('''CREATE TABLE IF NOT EXISTS pnl_log (
            date TEXT PRIMARY KEY, pnl REAL
        )''')
        self.conn.commit()

    def log_trade(self, trade):
        c = self.conn.cursor()
        c.execute('''INSERT INTO trades
            (bot, market, direction, size, entry, stop, target, confidence, status, entry_time, reason)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
            (trade['bot'], trade['market'], trade['direction'], trade['size'],
             trade['entry'], trade['stop'], trade['target'], trade['confidence'],
             trade['status'], trade['entry_time'], trade['reason']))
        self.conn.commit()

    def update_trade(self, trade_id, exit_price, exit_time, pnl, status):
        c = self.conn.cursor()
        c.execute('''UPDATE trades SET exit_price=?, exit_time=?, pnl=?, status=?
            WHERE id=?''', (exit_price, exit_time, pnl, status, trade_id))
        self.conn.commit()

    def get_open_trades(self, bot=None):
        c = self.conn.cursor()
        if bot:
            c.execute("SELECT * FROM trades WHERE status='open' AND bot=?", (bot,))
        else:
            c.execute("SELECT * FROM trades WHERE status='open'")
        return c.fetchall()

    def get_trades(self, limit=100):
        c = self.conn.cursor()
        c.execute("SELECT * FROM trades ORDER BY entry_time DESC LIMIT ?", (limit,))
        return c.fetchall()

    def log_pnl(self, date, pnl):
        c = self.conn.cursor()
        c.execute("REPLACE INTO pnl_log (date, pnl) VALUES (?, ?)", (date, pnl))
        self.conn.commit()

    def get_pnl(self, date):
        c = self.conn.cursor()
        c.execute("SELECT pnl FROM pnl_log WHERE date=?", (date,))
        res = c.fetchone()
        return res[0] if res else 0

    def set_bot_status(self, bot, active, open_trades):
        c = self.conn.cursor()
        c.execute('''REPLACE INTO bot_status (bot, active, open_trades, last_action)
            VALUES (?, ?, ?, ?)''', (bot, int(active), open_trades, datetime.utcnow().isoformat()))
        self.conn.commit()

    def get_bot_status(self, bot):
        c = self.conn.cursor()
        c.execute("SELECT * FROM bot_status WHERE bot=?", (bot,))
        return c.fetchone()

    def close(self):
        self.conn.close()


───────────────────────────────────────────────
📄 status.json
───────────────────────────────────────────────

{"Momentum": {"last_heartbeat": "2025-06-15T09:54:08.415902"}, "Wick": {"last_heartbeat": "2025-06-15T09:54:08.419416"}, "Trend": {"last_heartbeat": "2025-06-15T09:54:08.421985"}}


───────────────────────────────────────────────
📄 stop_bots.json
───────────────────────────────────────────────

{"stop": false}



───────────────────────────────────────────────
📄 test_account.py
───────────────────────────────────────────────

import requests
import json

# === Your IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
MARKETS_URL = f"{BASE_URL}/markets"
ACCOUNTS_URL = f"{BASE_URL}/accounts"
POSITIONS_URL = f"{BASE_URL}/positions/otc"

# === Use the FTSE 100 Spreadbet Epic as per your message ===
EPIC = "IX.D.SPTRD.DAILY.IP"  # FTSE 100 (Spreadbet, Daily Funded Bet)

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {"identifier": USERNAME, "password": PASSWORD}
    resp = requests.post(LOGIN_URL, headers=headers, json=payload)
    resp.raise_for_status()
    cst = resp.headers["CST"]
    sec = resp.headers["X-SECURITY-TOKEN"]
    # Get current account
    accs = requests.get(ACCOUNTS_URL, headers={
        "X-IG-API-KEY": API_KEY,
        "CST": cst,
        "X-SECURITY-TOKEN": sec,
        "Accept": "application/json"
    })
    accs.raise_for_status()
    acc_data = accs.json()
    # Print all accounts for confirmation
    print("\n=== IG Accounts ===")
    for a in acc_data["accounts"]:
        print(f"AccountId: {a['accountId']} | Type: {a['accountType']} | Name: {a['accountName']} | Preferred: {a['preferred']}")
    # Get preferred account (should be SB)
    preferred = next((a for a in acc_data["accounts"] if a["preferred"]), acc_data["accounts"][0])
    print(f"\n>>> Using Account: {preferred['accountId']} | Type: {preferred['accountType']}\n")
    return cst, sec, preferred['accountId']

def check_product_type(epic):
    cst, sec, _ = ig_login()
    headers = {
        "X-IG-API-KEY": API_KEY,
        "CST": cst,
        "X-SECURITY-TOKEN": sec,
        "Accept": "application/json"
    }
    url = f"{MARKETS_URL}/{epic}"
    print(f"Requesting market info for epic: {epic}")
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    data = resp.json()
    instr = data["instrument"]
    print("\n=== Instrument Info ===")
    print(f"Name:         {instr.get('name')}")
    print(f"Epic:         {epic}")
    print(f"Product type: {instr.get('productType')}")
    print(f"Expiry:       {instr.get('expiry')}")
    print(f"Market type:  {instr.get('type')}")
    print(f"Lot size:     {instr.get('lotSize')}")
    print(f"Currency:     {instr.get('currency')}")
    print("\n---- FULL INSTRUMENT DATA ----")
    for k, v in instr.items():
        print(f"{k:20}: {v}")

def place_spreadbet_order(epic, direction="BUY", size=1):
    cst, sec, account_id = ig_login()
    headers = {
        "X-IG-API-KEY": API_KEY,
        "CST": cst,
        "X-SECURITY-TOKEN": sec,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    # Order payload as per IG support (expiry: "DFB", no currencyCode, forceOpen True)
    payload = {
        "epic": epic,
        "expiry": "DFB",
        "direction": direction,
        "size": size,              # stake per point
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "guaranteedStop": False,
        "forceOpen": True,
        # Optional: set stop/limit as needed
        # "stopDistance": 20,
        # "limitDistance": 40
    }
    print("\n=== Sending Order Payload ===")
    print(json.dumps(payload, indent=2))
    resp = requests.post(POSITIONS_URL, headers=headers, json=payload)
    try:
        resp.raise_for_status()
        print("\nOrder SENT! Response:")
        print(resp.json())
    except Exception as e:
        print("\nOrder ERROR:")
        print(resp.text)
        raise

if __name__ == "__main__":
    # Step 1: Show account and epic info
    check_product_type(EPIC)
    # Step 2: Place a test spreadbet order (uncomment to test order placement):
    # place_spreadbet_order(EPIC, direction="BUY", size=1)


───────────────────────────────────────────────
📄 test_dax_daily_order.py
───────────────────────────────────────────────

from utils.execution import place_ig_order
import config

print("[LIVE MODE TEST] (Using DAX Daily Epic)")
print("DEBUG_MODE:", config.DEBUG_MODE)
print("IG_APP_KEY:", config.IG_APP_KEY)
print("IG_ACCOUNT_ID:", config.IG_ACCOUNT_ID)

epic = "IX.D.DAX.DAILY.IP"  # DAX Daily (from your IG platform link)

print(f"\nPlacing test order for {epic} ...")
result = place_ig_order(epic, "buy", 1.0, 7000, 7200)
print("Test Order Result:")
for key, value in result.items():
    print(f"  {key}: {value}")


───────────────────────────────────────────────
📄 test_email_templates.py
───────────────────────────────────────────────

# test_email_templates.py

from utils.emailer import (
    send_trade_placed_email,
    send_trade_outcome_email,
    send_bot_offline_email,
    send_crash_email,
    send_daily_summary_email,
    send_weekly_summary_email
)

# 1. Trade Placed
send_trade_placed_email(
    market="CS.D.NAS100.MINI.IP",
    direction="buy",
    size=100,
    sl=1234.5,
    tp=1250.0,
    confidence=82,
    strategy="Momentum Breakout"
)

# 2. Trade Won
send_trade_outcome_email(
    market="CS.D.SPX.MINI.IP",
    direction="sell",
    entry_price=4000.0,
    exit_price=3950.0,
    profit=500.0
)

# 3. Trade Lost
send_trade_outcome_email(
    market="CS.D.DAX.MINI.IP",
    direction="buy",
    entry_price=15000.0,
    exit_price=14900.0,
    profit=-100.0
)

# 4. Bot Offline Notification
send_bot_offline_email()

# 5. Crash Notification
send_crash_email("This is a TEST exception message.")

# 6. Daily Summary
send_daily_summary_email()

# 7. Weekly Summary
send_weekly_summary_email()

print("Test emails sent. Check your inbox!")



───────────────────────────────────────────────
📄 test_env.py
───────────────────────────────────────────────

import requests
import os
from dotenv import load_dotenv

load_dotenv()

IG_USERNAME = os.getenv("IG_USERNAME")
IG_PASSWORD = os.getenv("IG_PASSWORD")
IG_APP_KEY = os.getenv("IG_APP_KEY")
IG_ACCOUNT_ID = os.getenv("IG_ACCOUNT_ID")
IG_API_BASE_URL = os.getenv("IG_API_BASE_URL", "https://demo-api.ig.com/gateway/deal")

def ig_login(session):
    url = f"{IG_API_BASE_URL}/session"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    payload = {"identifier": IG_USERNAME, "password": IG_PASSWORD}
    print("DEBUG IG LOGIN PAYLOAD:", payload)
    print("DEBUG IG LOGIN HEADERS:", headers)
    resp = session.post(url, headers=headers, json=payload)
    try:
        resp.raise_for_status()
    except Exception as e:
        print("DEBUG IG LOGIN RESPONSE:", resp.text)
        raise
    cst = resp.headers["CST"]
    xst = resp.headers["X-SECURITY-TOKEN"]
    return {"CST": cst, "X-SECURITY-TOKEN": xst}

def ig_get_positions(session, tokens):
    url = IG_API_BASE_URL + "/positions"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    print("GET /positions HEADERS:", headers)
    resp = session.get(url, headers=headers)
    print("DEBUG POSITIONS RESPONSE:", resp.text)
    resp.raise_for_status()
    return resp.json()

def ig_get_market(session, tokens, epic):
    url = IG_API_BASE_URL + f"/markets/{epic}"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    print(f"GET /markets/{epic} HEADERS:", headers)
    resp = session.get(url, headers=headers)
    print(f"DEBUG MARKETS/{epic} RESPONSE:", resp.text)
    resp.raise_for_status()
    return resp.json()

def ig_get_watchlists(session, tokens):
    url = IG_API_BASE_URL + "/watchlists"
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": tokens["CST"],
        "X-SECURITY-TOKEN": tokens["X-SECURITY-TOKEN"],
        "Accept": "application/json"
    }
    print("GET /watchlists HEADERS:", headers)
    resp = session.get(url, headers=headers)
    print("DEBUG WATCHLISTS RESPONSE:", resp.text)
    resp.raise_for_status()
    return resp.json()

if __name__ == "__main__":
    session = requests.Session()
    tokens = ig_login(session)

    # Get open positions
    try:
        positions = ig_get_positions(session, tokens)
        print("\nOpen Positions JSON:", positions)
    except Exception as e:
        print("Could not get positions:", e)

    # Get info for a specific market (replace 'CS.D.EURUSD.MINI.IP' with an EPIC you are interested in)
    try:
        market_info = ig_get_market(session, tokens, 'CS.D.EURUSD.MINI.IP')
        print("\nMarket Info JSON:", market_info)
    except Exception as e:
        print("Could not get market info:", e)

    # Get watchlists
    try:
        watchlists = ig_get_watchlists(session, tokens)
        print("\nWatchlists JSON:", watchlists)
    except Exception as e:
        print("Could not get watchlists:", e)


───────────────────────────────────────────────
📄 test_ig_login.py
───────────────────────────────────────────────

from ig_service import IGService
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD, IG_ACCOUNT_ID

ig = IGService(
    username=IG_USERNAME,
    password=IG_PASSWORD,
    api_key=IG_APP_KEY,
    account_id=IG_ACCOUNT_ID,
    base_url=IG_API_BASE_URL
)

ig.login()
print("✅ IG connection successful!")


───────────────────────────────────────────────
📄 test_list_epics.py
───────────────────────────────────────────────

import requests

# === IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"
PRICES_URL = f"{BASE_URL}/prices"

# Epic for EUR/USD forex pair
EPIC = "CS.D.EURUSD.CFD.IP"
RESOLUTION = "HOUR"
NUM_CANDLES = 10

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }
    try:
        response = requests.post(LOGIN_URL, headers=headers, json=payload)
        response.raise_for_status()
        CST = response.headers.get("CST")
        SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")
        print("✅ IG login successful.")
        return CST, SECURITY_TOKEN
    except requests.exceptions.RequestException as e:
        print(f"❌ Login failed: {e}")
        return None, None

def fetch_candles(cst, security_token, epic):
    headers = {
        "X-IG-API-KEY": API_KEY,
        "X-SECURITY-TOKEN": security_token,
        "CST": cst,
        "Version": "3",
        "Accept": "application/json"
    }
    url = f"{PRICES_URL}/{epic}?resolution={RESOLUTION}&max={NUM_CANDLES}"
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 403:
            print(f"❌ 403 Forbidden for {epic} – IG may not allow this market in demo right now.")
            return
        response.raise_for_status()
        prices = response.json().get("prices", [])
        print(f"\n📊 EUR/USD – Last {NUM_CANDLES} {RESOLUTION} candles:")
        for p in prices:
            dt = p.get("snapshotTime")
            o = p["openPrice"]["bid"]
            h = p["highPrice"]["bid"]
            l = p["lowPrice"]["bid"]
            c = p["closePrice"]["bid"]
            v = p["lastTradedVolume"]
            print(f"{dt}: O={o}, H={h}, L={l}, C={c}, V={v}")
    except requests.exceptions.RequestException as e:
        print(f"❌ Failed to fetch candles: {e}")
    except ValueError as ve:
        print(f"❌ JSON decoding error: {ve}")

if __name__ == "__main__":
    CST, SEC_TOKEN = ig_login()
    if CST and SEC_TOKEN:
        fetch_candles(CST, SEC_TOKEN, EPIC)
    else:
        print("⛔️ Cannot proceed: Login credentials invalid or failed.")


───────────────────────────────────────────────
📄 test_logins.py
───────────────────────────────────────────────

import requests

# === IG Credentials ===
API_KEY = "d903c31346c109a5d0f8bb8a9b37c4723054444a"
USERNAME = "amerele32"
PASSWORD = "Eplindefete1@"

# === API Endpoints ===
BASE_URL = "https://demo-api.ig.com/gateway/deal"
LOGIN_URL = f"{BASE_URL}/session"

def ig_login():
    headers = {
        "X-IG-API-KEY": API_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Version": "2"  # IMPORTANT: version 2 returns extra details in body
    }
    payload = {
        "identifier": USERNAME,
        "password": PASSWORD
    }

    try:
        response = requests.post(LOGIN_URL, headers=headers, json=payload)
        response.raise_for_status()

        # Extract session headers
        CST = response.headers.get("CST")
        SECURITY_TOKEN = response.headers.get("X-SECURITY-TOKEN")

        # Extract response body for account info
        data = response.json()
        current_account = data.get("currentAccountId")
        lightstreamer_endpoint = data.get("lightstreamerEndpoint", "N/A")

        print("✅ IG login successful.")
        print("\n📊 Session Details:")
        print(f"Current Account ID: {current_account}")
        print(f"Lightstreamer Endpoint: {lightstreamer_endpoint}")
        print(f"CST: {CST}")
        print(f"X-SECURITY-TOKEN: {SECURITY_TOKEN}")
        return CST, SECURITY_TOKEN

    except requests.exceptions.RequestException as e:
        print(f"❌ Login failed: {e}")
        return None, None

if __name__ == "__main__":
    CST, SEC_TOKEN = ig_login()
    if not (CST and SEC_TOKEN):
        print("⛔️ Unable to verify session. Exiting.")


───────────────────────────────────────────────
📄 test_order.py
───────────────────────────────────────────────

from utils.execution import place_ig_order, place_trade
import config

print("DEBUG_MODE:", config.DEBUG_MODE)
print("IG_APP_KEY:", config.IG_APP_KEY)
print("IG_ACCOUNT_ID:", config.IG_ACCOUNT_ID)

# Test each of your new spread betting epics
epics = [
    "IX.D.NASDAQ.IFS.IP",  # Nasdaq 100
    "IX.D.FTSE.IFM.IP",    # FTSE 100
    "IX.D.DAX.IFS.IP",     # DAX 40
    "IX.D.SPTRD.IFS.IP"    # S&P 500
]

for epic in epics:
    print(f"\nPlacing test order for {epic} ...")
    result = place_ig_order(epic, "buy", 1.0, 7000, 7200)
    print("Test Order Result:")
    for key, value in result.items():
        print(f"  {key}: {value}")


───────────────────────────────────────────────
📄 test_timeframes.py
───────────────────────────────────────────────

"""
test_timeframes.py – Testing candle fetching for various resolutions.
"""

import json
from utils.data import fetch_candles

# Market epic for US Tech 100 (Nasdaq)
market = "IX.D.NASDAQ.CASH.IP"

# List of timeframe resolutions to test. Use IG API’s expected values.
resolutions = ["MINUTE", "MINUTE_5", "MINUTE_15", "MINUTE_30", "HOUR", "DAY"]

print(f"Testing candle fetching for market: {market}\n")

for res in resolutions:
    print(f"--- Testing resolution: {res} ---")
    try:
        # Use positional arguments to match your function signature
        candles = fetch_candles(market, res, 5)
        print(f"Received {len(candles)} candles:")
        print(json.dumps(candles, indent=2))
    except Exception as e:
        print(f"Resolution {res} failed with error: {e}")
    print("-" * 50)


───────────────────────────────────────────────
📄 bots\New Text Document.txt
───────────────────────────────────────────────




───────────────────────────────────────────────
📄 bots\__init__.py
───────────────────────────────────────────────




───────────────────────────────────────────────
📄 bots\breakout.py
───────────────────────────────────────────────

"""
Simple 20-bar high/low breakout bot (ATR-based SL/TP), with swing/structure filter and multi-TF confirmation.
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.indicators import atr_pips, swing_highs_lows
from utils.state import update_balance
from config import CONFIDENCE_MIN_MOMENTUM, MARKETS, BOT_STRATEGY_PARAMS, INDICATOR_PARAMS

LOOKBACK = 20  # bars

def breakout_signal(candles, higher_tf_candles=None, signal_params=None):
    if len(candles) < LOOKBACK + 1:
        print(f"[breakout_signal] Skipping: not enough candles ({len(candles)})")
        return None

    # Defensive: ensure all required OHLC fields are present and valid
    for idx, b in enumerate(candles[-LOOKBACK - 1:]):
        if not isinstance(b, dict) or any(b.get(field) is None for field in ("open", "high", "low", "close")):
            print(f"[breakout_signal] Skipping: missing OHLC in candle {idx}: {b}")
            return None

    bot_cfg = BOT_STRATEGY_PARAMS.get("breakout", {})
    struct_cfg = bot_cfg.get("structure_filter", {})
    swing_lookback = struct_cfg.get("lookback", INDICATOR_PARAMS.get("SWING", {}).get("lookback", 5))

    highs = [b["high"] for b in candles[-LOOKBACK - 1 : -1]]
    lows  = [b["low"]  for b in candles[-LOOKBACK - 1 : -1]]
    last  = candles[-1]

    # --- Structure filter: only trade if breaking a recent swing high/low ---
    swings = swing_highs_lows(candles, lookback=swing_lookback)
    swing_highs = [s['price'] for s in swings if s['type'] == 'high' and s.get('price') is not None]
    swing_lows  = [s['price'] for s in swings if s['type'] == 'low' and s.get('price') is not None]

    direction = None
    reason = ""
    if last["close"] > max(highs):
        if swing_highs and last["close"] > max(swing_highs[-2:]):
            direction = "buy"
            reason = "20-bar breakout + swing high break"
        else:
            print(f"[breakout_signal] Skipping: not breaking recent swing high (market: {last.get('market', 'unknown')}).")
            return None
    elif last["close"] < min(lows):
        if swing_lows and last["close"] < min(swing_lows[-2:]):
            direction = "sell"
            reason = "20-bar breakout + swing low break"
        else:
            print(f"[breakout_signal] Skipping: not breaking recent swing low (market: {last.get('market', 'unknown')}).")
            return None
    else:
        # Optional: log no breakout
        print(f"[breakout_signal] No breakout detected this cycle (market: {last.get('market', 'unknown')}).")
        return None

    # --- Multi-timeframe confirmation (5Min + 1Hour) ---
    if higher_tf_candles:
        # Defensive: ensure all required OHLC fields in higher TF
        for idx, b in enumerate(higher_tf_candles[-LOOKBACK - 1:]):
            if not isinstance(b, dict) or any(b.get(field) is None for field in ("open", "high", "low", "close")):
                print(f"[breakout_signal] Skipping: missing OHLC in higher TF candle {idx}: {b}")
                return None
        higher_highs = [b["high"] for b in higher_tf_candles[-LOOKBACK - 1 : -1]]
        higher_lows  = [b["low"]  for b in higher_tf_candles[-LOOKBACK - 1 : -1]]
        higher_close = higher_tf_candles[-1]["close"]
        higher_market = higher_tf_candles[-1].get("market", "unknown")
        if direction == "buy" and higher_close <= max(higher_highs):
            print(f"[breakout_signal] Skipping: higher TF not breaking out upwards (market: {higher_market}).")
            return None
        if direction == "sell" and higher_close >= min(higher_lows):
            print(f"[breakout_signal] Skipping: higher TF not breaking out downwards (market: {higher_market}).")
            return None

    market_name = last.get("market", list(MARKETS.keys())[0] if isinstance(MARKETS, dict) and MARKETS else "unknown")
    atr = atr_pips(candles, INDICATOR_PARAMS.get("ATR", {}).get("period", 14))
    if atr is None or atr <= 0:
        print(f"[breakout_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    close = last["close"]
    sl = close - 1.5 * atr if direction == "buy" else close + 1.5 * atr
    tp = close + 3.0 * atr if direction == "buy" else close - 3.0 * atr

    trade_signal = {
        "direction":  direction,
        "entry":      close,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": bot_cfg.get("min_confidence", CONFIDENCE_MIN_MOMENTUM),
        "reason":     reason,
        "market":     market_name,
    }

    print(f"[breakout_signal] Trade signal generated for {market_name}: {trade_signal}")
    return trade_signal

class BreakoutBot(BaseBot):
    def __init__(self, name="breakout", signal_func=breakout_signal,
                 fetch_candles=fetch_candles, fetch_higher_candles=None, place_trade=place_trade):
        # fetch_candles and fetch_higher_candles are now both lambdas from the launcher
        super().__init__(name, signal_func, place_trade, fetch_candles)
        self.fetch_higher_candles = fetch_higher_candles
        self.order = None

    def enter_trade(self, signal, current_time, size=1):
        """
        Places a trade and stores the order information.
        """
        if signal is None:
            print(f"[BreakoutBot] No valid trade signal at {current_time}")
            return

        direction = signal.get("direction")
        entry = signal.get("entry")
        sl = signal.get("sl")
        tp = signal.get("tp")
        market = signal.get("market")
        confidence = signal.get("confidence", 90)
        reason = signal.get("reason", "")
        if not all([direction, entry, sl, tp, market]):
            print(f"[BreakoutBot] Incomplete signal at {current_time}: {signal}")
            return

        # Place trade (use your own place_trade logic)
        trade_result = self.place_trade(direction, entry, sl=sl, tp=tp, size=size)
        self.order = {
            "direction": direction,
            "entry_price": entry,
            "position_size": size,
            "timestamp": current_time,
            "market": market,
            "sl": sl,
            "tp": tp,
            "confidence": confidence,
            "reason": reason,
            "trade_result": trade_result,
        }
        print(f"[BreakoutBot] Entered {direction} trade at {entry} (size={size}) at {current_time} for {market}")

    def close_trade(self, exit_price):
        if isinstance(self.order, dict):
            entry     = self.order.get("entry_price")
            size      = self.order.get("position_size", 1)
            direction = self.order.get("direction")
            market    = self.order.get("market", "unknown")

            if entry is not None and isinstance(size, (int, float)):
                if direction == "buy":
                    profit = (exit_price - entry) * size
                else:
                    profit = (entry - exit_price) * size
            else:
                profit = 0

            self.order["profit"] = round(profit, 2)
            print(f"Trade closed at {exit_price} on {market}. Profit: {profit}. Order: {self.order}")
            update_balance(self.order.get("profit", 0))
            self.order = None

    def run(self):
        import time
        try:
            while True:
                candles = self.fetch_candles()
                market = "unknown"
                if candles and isinstance(candles, list) and isinstance(candles[-1], dict) and "market" in candles[-1]:
                    market = candles[-1]["market"]
                elif isinstance(MARKETS, dict) and MARKETS:
                    market = list(MARKETS.keys())[0]
                elif isinstance(MARKETS, list) and MARKETS:
                    market = MARKETS[0]
                print(f"[BreakoutBot] Checking for signal at {time.strftime('%Y-%m-%d %H:%M:%S')} for {market}")
                higher_candles = self.fetch_higher_candles() if self.fetch_higher_candles else None
                signal = self.signal_func(candles, higher_tf_candles=higher_candles)
                if signal:
                    self.enter_trade(signal, current_time=time.strftime("%Y-%m-%d %H:%M:%S"))
                time.sleep(60)
        except Exception as e:
            print(f"[BreakoutBot] ERROR in run loop: {e}")

if __name__ == "__main__":
    # For standalone testing. In deployment, use the launcher with CandleManager!
    BreakoutBot().run()


───────────────────────────────────────────────
📄 bots\meanreversion.py
───────────────────────────────────────────────

"""
bots/meanreversion.py
RSI-based mean-reversion bot (oversold <30, overbought >70) with ADX regime and multi-TF confirmation.
"""

import datetime
import time
from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.indicators import atr_pips, adx_last
from utils.state import get_balance, update_balance
from config import CONFIDENCE_MIN_MOMENTUM, MARKETS, BOT_STRATEGY_PARAMS, INDICATOR_PARAMS, RISK_PCT

RSI_PERIOD = 14

def _rsi(values, period=14):
    """Calculates RSI based on price history."""
    if len(values) < period + 1:
        return [50] * len(values)
    gains, losses = [], []
    for i in range(1, len(values)):
        diff = values[i] - values[i - 1]
        gains.append(max(diff, 0))
        losses.append(abs(min(diff, 0)))
    avg_gain = sum(gains[:period]) / period
    avg_loss = sum(losses[:period]) / period or 1e-9

    rsi_series = [50] * (period + 1)
    for i in range(period + 1, len(values)):
        gain = gains[i - 1]
        loss = losses[i - 1]
        avg_gain = (avg_gain * (period - 1) + gain) / period
        avg_loss = (avg_loss * (period - 1) + loss) / period
        rs = avg_gain / (avg_loss or 1e-9)
        rsi_series.append(100 - 100 / (1 + rs))
    return rsi_series

def meanreversion_signal(candles, higher_tf_candles=None, signal_params=None):
    print(f"[meanreversion_signal] Called with {len(candles)} candles | higher_tf: {len(higher_tf_candles) if higher_tf_candles else 0}")

    if not candles or len(candles) < RSI_PERIOD + 2:
        print(f"[meanreversion_signal] Skipping: not enough candles ({len(candles) if candles else 0} < {RSI_PERIOD + 2})")
        return None

    closes = [b.get("close") for b in candles]
    if any(c is None for c in closes):
        print("[meanreversion_signal] Skipping: some closes are None in candles")
        return None

    # === ADX regime filter: only trade if ADX <= threshold (ranging) ===
    bot_cfg = BOT_STRATEGY_PARAMS.get("meanreversion", {})
    regime_cfg = bot_cfg.get("regime_filter", {})
    adx_period = regime_cfg.get("adx_period", INDICATOR_PARAMS.get("ADX", {}).get("period", 14))
    adx_max = regime_cfg.get("adx_max", 20)
    adx_val = adx_last(candles, adx_period)
    if adx_val is None or adx_val > adx_max:
        print(f"[meanreversion_signal] Skipping: ADX {adx_val} > threshold {adx_max}")
        return None

    rsi = _rsi(closes, RSI_PERIOD)[-1]

    # === Multi-timeframe confirmation (5Min + 30Min) ===
    if higher_tf_candles:
        higher_closes = [b.get("close") for b in higher_tf_candles]
        if any(c is None for c in higher_closes):
            print("[meanreversion_signal] Skipping: some closes are None in higher_tf_candles")
            return None
        higher_rsi = _rsi(higher_closes, RSI_PERIOD)[-1]
        higher_adx_val = adx_last(higher_tf_candles, adx_period)
        if higher_adx_val is None or higher_adx_val > adx_max:
            print(f"[meanreversion_signal] Skipping: Higher TF ADX {higher_adx_val} > threshold {adx_max}")
            return None
        if (rsi < 30 and higher_rsi < 30) or (rsi > 70 and higher_rsi > 70):
            pass  # Alignment for mean reversion
        elif abs(rsi - higher_rsi) > 20:
            print(f"[meanreversion_signal] Skipping: RSI disagreement 5Min/30Min: {rsi} vs {higher_rsi}")
            return None

    # Market fallback (always ensure this is set and valid)
    market_name = None
    if "market" in candles[-1]:
        market_name = candles[-1]["market"]
    elif "market" in candles[0]:
        market_name = candles[0]["market"]
    elif isinstance(MARKETS, dict) and MARKETS:
        # If MARKETS is a dict, prefer the key as the market name
        market_name = next(iter(MARKETS.keys()))
    elif isinstance(MARKETS, list) and MARKETS:
        market_name = MARKETS[0]
    else:
        market_name = "UNKNOWN"

    atr = atr_pips(candles, INDICATOR_PARAMS.get("ATR", {}).get("period", 14))
    if atr is None or atr <= 0:
        print(f"[meanreversion_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    close = closes[-1]

    if rsi < 30:
        direction = "buy"
        sl = close - 1.0 * atr
        tp = close + 2.0 * atr
    elif rsi > 70:
        direction = "sell"
        sl = close + 1.0 * atr
        tp = close - 2.0 * atr
    else:
        print(f"[meanreversion_signal] Skipping: RSI not overbought/oversold (RSI={rsi})")
        return None

    return {
        "market":     market_name,
        "direction":  direction,
        "entry":      close,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": bot_cfg.get("min_confidence", CONFIDENCE_MIN_MOMENTUM),
        "reason":     "RSI mean-reversion + ADX regime + multi-TF confirm",
        "adx":        adx_val
    }

class MeanRevBot(BaseBot):
    def __init__(self, name="meanreversion", signal_func=meanreversion_signal,
                 fetch_candles=fetch_candles, fetch_higher_candles=None, place_trade=place_trade):
        super().__init__(name, signal_func, place_trade, fetch_candles)
        self.fetch_higher_candles = fetch_higher_candles
        self.order = None

    def enter_trade(self, direction, entry, market, current_time, size=None, sl=None, tp=None):
        if size is None:
            # Use risk-based position sizing similar to scalping
            if sl is not None:
                sl_offset = abs(entry - sl)
            else:
                sl_offset = 0.001
            risk_amount = get_balance() * RISK_PCT
            size = risk_amount / sl_offset if sl_offset else 1

        trade = self.place_trade(market=market, direction=direction, size=size, sl=sl, tp=tp)
        self.order = {
            "direction": direction,
            "entry_price": entry,
            "position_size": size,
            "entry_time": current_time,
            "market": market,
            "stop_loss": sl,
            "take_profit": tp,
            "trade_result": trade
        }
        print(f"[MeanRevBot] Entered {direction} trade at {entry} (size={size}) at {current_time} for {market}")

    def close_trade(self, exit_price):
        if not isinstance(self.order, dict):
            return
        entry = self.order.get("entry_price")
        size = self.order.get("position_size", 1)
        direction = self.order.get("direction")
        market = self.order.get("market", "unknown")
        if entry is None or size == 0:
            print(f"Invalid order parameters for {market}. Order:", self.order)
            return

        profit = (exit_price - entry) * size if direction == "buy" else (entry - exit_price) * size
        self.order["profit"] = round(profit, 2)
        print(f"Trade closed at {exit_price} on {market}. Profit: {profit}. Order: {self.order}")
        update_balance(self.order.get("profit", 0))
        self.order = None

    def run(self):
        try:
            while True:
                candles = self.fetch_candles()
                market = "unknown"
                if candles and isinstance(candles, list) and "market" in candles[-1]:
                    market = candles[-1]["market"]
                elif candles and isinstance(candles, list) and "market" in candles[0]:
                    market = candles[0]["market"]
                elif isinstance(MARKETS, dict) and MARKETS:
                    market = next(iter(MARKETS.keys()))
                elif isinstance(MARKETS, list) and MARKETS:
                    market = MARKETS[0]
                print(f"[MeanRevBot] Checking for signal at {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} for {market}")
                higher_candles = self.fetch_higher_candles() if self.fetch_higher_candles else None
                signal = self.signal_func(candles, higher_tf_candles=higher_candles)
                if signal and isinstance(signal, dict):
                    direction = signal.get('direction')
                    entry = signal.get('entry', candles[-1]['close'] if candles else None)
                    market = signal.get('market', market)
                    sl = signal.get('sl')
                    tp = signal.get('tp')
                    if direction is not None and entry is not None and market != "UNKNOWN":
                        self.enter_trade(direction, entry, market, datetime.datetime.now(), sl=sl, tp=tp)
                    else:
                        print(f"No candidate available. Aborting trade entry for {market}.")
                else:
                    print(f"No candidate available. Aborting trade entry for {market}.")
                time.sleep(60)
        except Exception as e:
            print(f"[MeanRevBot] ERROR in run loop: {e}")

# ─── Module‐level signal for launcher.py to import ─────────────────
def meanreversion_signal_entry(candles, higher_tf_candles=None):
    bot = MeanRevBot()
    res = bot.signal_func(candles, higher_tf_candles=higher_tf_candles)
    if isinstance(res, dict):
        return res
    else:
        return None


───────────────────────────────────────────────
📄 bots\scalping.py
───────────────────────────────────────────────

# SCALPING.PY – High-Frequency Scalping Bot for Monarch Suite

import datetime
import time
import random
import threading

from base_bot import BaseBot
from utils.execution import place_trade
from utils.state     import get_balance, update_balance
from utils.data      import fetch_candles
from config          import MARKETS, RISK_PCT

class ScalpingBot(BaseBot):
    def __init__(
        self, 
        name="scalping", 
        signal_func=None, 
        fetch_candles=fetch_candles, 
        fetch_higher_candles=None, 
        place_trade=place_trade
    ):
        super().__init__(
            name=name,
            signal_func=signal_func or self.generate_signal,
            place_trade=place_trade,
            fetch_candles=fetch_candles
        )

        self.fetch_higher_candles = fetch_higher_candles
        self.account_balance        = get_balance()
        self.risk_percentage        = RISK_PCT
        self.stop_loss_pips         = 3
        self.profit_target_min_pips = 6
        self.profit_target_max_pips = 15
        self.pip_value              = 0.0001
        self.ema_period             = 9
        self.atr_period             = 14

        self.active_candidate = None
        self.order            = None
        self.candle_history   = []
        self.price_history    = []
        self.current_market   = None
        self.lock             = threading.Lock()

    def calculate_ema(self, prices, period):
        if len(prices) == 0:
            return None
        alpha = 2 / (period + 1)
        ema = prices[0]
        for price in prices[1:]:
            ema = alpha * price + (1 - alpha) * ema
        return ema

    def calculate_atr(self, candles, period):
        if len(candles) < 2:
            return 0
        trs = []
        for i in range(1, len(candles)):
            high       = candles[i]['high']
            low        = candles[i]['low']
            prev_close = candles[i-1]['close']
            tr = max(
                high - low,
                abs(high - prev_close),
                abs(low - prev_close)
            )
            trs.append(tr)
        return sum(trs[-period:]) / period if len(trs) >= period else sum(trs) / len(trs)

    def is_trading_allowed(self, current_time):
        forbidden_periods = [
            (datetime.time(8,  0), datetime.time(8,  30)),
            (datetime.time(13, 30), datetime.time(14,  0))
        ]
        now_t = current_time.time()
        return not any(start <= now_t <= end for start, end in forbidden_periods)

    def check_candle_for_candidate(self, candle):
        candle_range = candle['high'] - candle['low']
        if candle_range <= 0:
            return None

        upper_wick = candle['high'] - max(candle['open'], candle['close'])
        lower_wick = min(candle['open'], candle['close']) - candle['low']

        if upper_wick / candle_range >= 0.5:
            return {'type': 'bearish', 'wick_tip': candle['high'], 'candle': candle}
        if lower_wick / candle_range >= 0.5:
            return {'type': 'bullish', 'wick_tip': candle['low'],  'candle': candle}
        return None

    def process_new_candle(self, candle, market):
        self.candle_history.append(candle)
        candidate = self.check_candle_for_candidate(candle)
        if candidate:
            self.active_candidate = candidate
            self.current_market   = market
            print(f"[{candle['time']}] New candidate detected ({market}): "
                  f"{candidate['type']} with wick tip at {candidate['wick_tip']}")

    def process_live_price(self, price, current_time):
        self.price_history.append(price)

        if not self.is_trading_allowed(current_time):
            return

        if self.active_candidate and not self.order:
            wick_tip  = self.active_candidate['wick_tip']
            threshold = 2 * self.pip_value
            if abs(price - wick_tip) <= threshold:
                recent = self.price_history[-self.ema_period:]
                ema    = self.calculate_ema(recent, self.ema_period)
                direction = self.active_candidate['type']
                if direction == 'bearish' and price < ema:
                    self.enter_trade(direction, price, current_time)
                elif direction == 'bullish' and price > ema:
                    self.enter_trade(direction, price, current_time)
                else:
                    print(f"[{current_time}] EMA filter not confirmed. Price: {price}, EMA: {ema} (market: {self.current_market or 'unknown'})")

        if self.order:
            self.update_trailing_stop(price)

    def enter_trade(self, trade_direction, entry_price, current_time):
        candidate = self.active_candidate
        if candidate is None:
            print(f"[{current_time}] No candidate available. Aborting trade entry for {self.current_market or 'unknown market'}.")
            return

        sl_offset = self.stop_loss_pips * self.pip_value
        if trade_direction == 'bearish':
            computed_sl = candidate['wick_tip'] + sl_offset
        else:
            computed_sl = candidate['wick_tip'] - sl_offset

        sl_dist = abs(entry_price - computed_sl)
        if sl_dist == 0:
            print(f"[{current_time}] ERROR: Computed stop-loss distance is zero for {self.current_market or 'unknown market'}. Aborting trade.")
            return

        tp_offset = self.profit_target_min_pips * self.pip_value
        if trade_direction == 'bearish':
            computed_tp = entry_price - tp_offset
        else:
            computed_tp = entry_price + tp_offset

        risk_amount   = get_balance() * self.risk_percentage
        position_size = risk_amount / sl_dist

        trade = self.place_trade(
            market    = self.current_market,
            direction = trade_direction,
            size      = position_size,
            sl        = computed_sl,
            tp        = computed_tp
        )

        # DEBUG: print trade type and value for diagnostics
        print("DEBUG: place_trade returned type:", type(trade), "value:", trade)
        print("DEBUG: place_trade function repr:", repr(self.place_trade))
        print("DEBUG: place_trade module:", getattr(self.place_trade, "__module__", "n/a"))
        print("DEBUG: place_trade qualname:", getattr(self.place_trade, "__qualname__", "n/a"))

        # Robust: Only assign self.order if trade is a dict (prevents crash on bool/None)
        if isinstance(trade, dict):
            self.order = {
                "direction": trade_direction,
                "entry_price": entry_price,
                "stop_loss": computed_sl,
                "take_profit": computed_tp,
                "position_size": position_size,
                "entry_time": current_time,
                "ticket_id": trade.get("ticket_id") if isinstance(trade, dict) else None,
                "market": self.current_market,
                "trade_result": trade,
            }
            print(f"[{current_time}] Trade executed on {self.current_market}: {trade_direction} at {entry_price} | SL: {computed_sl} | TP: {computed_tp} | Size: {position_size}")
        else:
            print(f"[{current_time}] Trade execution failed or invalid response for {self.current_market or 'unknown market'}: {trade}")

    def update_trailing_stop(self, current_price):
        if not self.order:
            return

        entry    = self.order['entry_price']
        sl       = self.order['stop_loss']
        distance = abs(entry - sl)
        profit   = (entry - current_price) if self.order['direction'] == 'bearish' else (current_price - entry)
        threshold = 2 * distance

        if self.order['direction'] == 'bearish' and profit > threshold:
            new_sl = current_price + distance
            if new_sl < sl:
                self.order['stop_loss'] = new_sl
                print(f"[{datetime.datetime.now()}] Trailing stop updated (bearish) to {new_sl} for {self.current_market or 'unknown market'}")

        if self.order['direction'] == 'bullish' and profit > threshold:
            new_sl = current_price - distance
            if new_sl > sl:
                self.order['stop_loss'] = new_sl
                print(f"[{datetime.datetime.now()}] Trailing stop updated (bullish) to {new_sl} for {self.current_market or 'unknown market'}")

    def close_trade(self, exit_price):
        if not isinstance(self.order, dict):
            return
        entry = self.order.get("entry_price")
        size = self.order.get("position_size", 1)
        direction = self.order.get("direction")
        market = self.order.get("market", "unknown")
        if entry is None or size == 0:
            print(f"Invalid order parameters for {market}. Order:", self.order)
            return

        profit = (exit_price - entry) * size if direction == "buy" else (entry - exit_price) * size
        self.order["profit"] = round(profit, 2)
        print(f"Trade closed at {exit_price} on {market}. Profit: {profit}. Order: {self.order}")
        update_balance(self.order.get("profit", 0))
        self.order = None

    def generate_signal(self, candles, higher_tf_candles=None):
        if not candles:
            return None

        last_candle = candles[-1]
        candidate   = self.check_candle_for_candidate(last_candle)
        if not candidate:
            print(f"[ScalpingBot] No candidate found for {last_candle.get('market', 'unknown')}.")
            return None

        direction = candidate['type']
        wick_tip  = candidate['wick_tip']
        sl_offset = self.stop_loss_pips * self.pip_value
        sl = wick_tip + sl_offset if direction == 'bearish' else wick_tip - sl_offset
        tp_offset = self.profit_target_min_pips * self.pip_value
        tp = wick_tip - tp_offset if direction == 'bearish' else wick_tip + tp_offset

        # Use first market if dict or just MARKETS[0] if list
        if isinstance(MARKETS, dict):
            default_market = next(iter(MARKETS.values()))
        elif isinstance(MARKETS, list):
            default_market = MARKETS[0]
        else:
            default_market = "UNKNOWN"

        return {
            "market":     last_candle.get("market", default_market),
            "direction":  direction,
            "entry":      last_candle.get("close", None),
            "sl":         sl,
            "tp":         tp,
            "confidence": 90,
            "reason":     "Scalping wick rejection"
        }

    def run(self):
        try:
            while True:
                candles = self.fetch_candles()
                market = "unknown"
                if candles and isinstance(candles, list) and "market" in candles[-1]:
                    market = candles[-1]["market"]
                elif isinstance(MARKETS, dict):
                    market = next(iter(MARKETS.values()))
                elif isinstance(MARKETS, list):
                    market = MARKETS[0]
                print(f"[ScalpingBot] Checking for signal at {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} for {market}")
                higher_candles = self.fetch_higher_candles() if self.fetch_higher_candles else None
                signal = self.signal_func(candles, higher_tf_candles=higher_candles)
                if signal and isinstance(signal, dict):
                    direction = signal.get('direction')
                    entry = signal.get('entry', candles[-1]['close'] if candles else None)
                    if direction is not None and entry is not None:
                        self.enter_trade(direction, entry, datetime.datetime.now())
                    else:
                        print(f"Signal missing direction or entry for {market}: {signal}")
                time.sleep(60)
        except Exception as e:
            print(f"[ScalpingBot] ERROR in run loop: {e}")

# ─── Module‐level signal for launcher.py to import ─────────────────
def scalping_signal(candles, higher_tf_candles=None):
    bot = ScalpingBot()
    res = bot.generate_signal(candles, higher_tf_candles=higher_tf_candles)
    if isinstance(res, dict):
        return res
    else:
        return None


───────────────────────────────────────────────
📄 bots\trend.py
───────────────────────────────────────────────

"""
EMA-cross trend bot – v2.3 (live execution with safe trade entry, ADX regime, multi-TF confirmation)
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_trade
from utils.indicators import atr_pips, adx_last
from utils.state import get_balance, update_balance
from config import ATR_PERIOD, MARKETS, RISK_PCT, BOT_STRATEGY_PARAMS, INDICATOR_PARAMS

def _ema_series(values, period):
    """Return full EMA list matching `values` length."""
    k = 2 / (period + 1)
    ema_vals = [values[0]]  # Seed with first value
    for price in values[1:]:
        ema_vals.append(price * k + ema_vals[-1] * (1 - k))
    return ema_vals

def trend_signal(candles, higher_tf_candles=None, signal_params=None):
    if len(candles) < 50:
        print("[trend_signal] Skipping: not enough candles")
        return None

    # Defensive: check for valid OHLC data
    for idx, b in enumerate(candles[-50:]):
        if not isinstance(b, dict) or any(b.get(field) is None for field in ("open", "high", "low", "close")):
            print(f"[trend_signal] Skipping: missing OHLC in candle {idx}: {b}")
            return None

    # === Regime filter: ADX threshold ===
    bot_cfg = BOT_STRATEGY_PARAMS.get("trend", {})
    regime_cfg = bot_cfg.get("regime_filter", {})
    adx_period = regime_cfg.get("adx_period", INDICATOR_PARAMS.get("ADX", {}).get("period", 14))
    adx_min = regime_cfg.get("adx_min", 22)
    adx_val = adx_last(candles, adx_period)
    if adx_val is None or adx_val < adx_min:
        print(f"[trend_signal] Skipping: ADX {adx_val} < threshold {adx_min}")
        return None

    closes = [b["close"] for b in candles if b.get("close") is not None]
    if len(closes) < 50:
        print("[trend_signal] Skipping: not enough valid closes")
        return None

    ema_fast = _ema_series(closes, 9)
    ema_slow = _ema_series(closes, 21)

    # === Multi-timeframe confirmation (5Min + 1Hour) ===
    direction = None
    if higher_tf_candles:
        higher_closes = [b["close"] for b in higher_tf_candles if b.get("close") is not None]
        if len(higher_closes) < 22:
            print("[trend_signal] Skipping: not enough higher TF closes")
            return None
        higher_ema_fast = _ema_series(higher_closes, 9)
        higher_ema_slow = _ema_series(higher_closes, 21)
        # Require higher timeframe EMA alignment with signal direction
        if ema_fast[-2] < ema_slow[-2] and ema_fast[-1] > ema_slow[-1]:
            # Buy signal: require higher TF fast > slow
            if higher_ema_fast[-1] <= higher_ema_slow[-1]:
                print("[trend_signal] Skipping: higher TF not bullish")
                return None
            direction = "buy"
        elif ema_fast[-2] > ema_slow[-2] and ema_fast[-1] < ema_slow[-1]:
            # Sell signal: require higher TF fast < slow
            if higher_ema_fast[-1] >= higher_ema_slow[-1]:
                print("[trend_signal] Skipping: higher TF not bearish")
                return None
            direction = "sell"
        else:
            print("[trend_signal] Skipping: no EMA cross")
            return None
    else:
        # Fallback: single timeframe logic if no higher_tf_candles provided
        if ema_fast[-2] < ema_slow[-2] and ema_fast[-1] > ema_slow[-1]:
            direction = "buy"
        elif ema_fast[-2] > ema_slow[-2] and ema_fast[-1] < ema_slow[-1]:
            direction = "sell"
        else:
            print("[trend_signal] Skipping: no EMA cross (single TF)")
            return None

    last_close = closes[-1]
    market_name = candles[0].get("market", list(MARKETS.keys())[0] if isinstance(MARKETS, dict) and MARKETS else "unknown")
    atr = atr_pips(candles, ATR_PERIOD)
    if atr is None or atr <= 0:
        print(f"[trend_signal] ATR unavailable for {market_name}. Skipping trade.")
        return None

    # Calculate stop-loss and take-profit based on ATR multiples
    sl = last_close - 1.5 * atr if direction == "buy" else last_close + 1.5 * atr
    tp = last_close + 3.0 * atr if direction == "buy" else last_close - 3.0 * atr

    trade_signal = {
        "direction":  direction,
        "entry":      last_close,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": bot_cfg.get("min_confidence", 80),
        "reason":     "EMA cross + ADX regime + multi-TF confirm",
        "market":     market_name,
        "adx":        adx_val
    }
    print(f"[trend_signal] Trade signal generated for {market_name}: {trade_signal}")
    return trade_signal

class TrendBot(BaseBot):
    def __init__(
        self, 
        name="trend", 
        signal_func=trend_signal, 
        fetch_candles=fetch_candles, 
        fetch_higher_candles=None, 
        place_trade=place_trade
    ):
        super().__init__(name, signal_func, place_trade, fetch_candles)
        self.fetch_higher_candles = fetch_higher_candles
        self.order = None

    def enter_trade(self, trade_signal, current_time):
        if trade_signal is None:
            return
        direction = trade_signal.get("direction")
        entry_price = trade_signal.get("entry")
        stop_loss = trade_signal.get("sl")
        take_profit = trade_signal.get("tp")
        market = trade_signal.get("market")
        confidence = trade_signal.get("confidence", 80)
        reason = trade_signal.get("reason", "")
        if not all([direction, entry_price, stop_loss, take_profit, market]):
            print(f"[{current_time}] Incomplete trade signal for {market}: {trade_signal}")
            return

        # Calculate risk amount and stop loss distance
        risk_amount = get_balance() * RISK_PCT
        sl_dist = abs(entry_price - stop_loss)
        if sl_dist == 0:
            print(f"[{current_time}] ERROR: Stop loss distance is zero for {market}. Aborting trade.")
            return

        position_size = risk_amount / sl_dist

        trade = self.place_trade(
            market=market,
            direction=direction,
            size=position_size,
            sl=stop_loss,
            tp=take_profit
        )
        if trade:
            self.order = {
                "direction": direction,
                "entry_price": entry_price,
                "stop_loss": stop_loss,
                "take_profit": take_profit,
                "position_size": position_size,
                "entry_time": current_time,
                "ticket_id": trade.get("ticket_id") if isinstance(trade, dict) else None,
                "market": market,
                "confidence": confidence,
                "reason": reason,
                "trade_result": trade,
            }
            print(f"[{current_time}] Trade executed on {market}: {direction} at {entry_price} | SL: {stop_loss} | TP: {take_profit} | Size: {position_size}")
        else:
            print(f"[{current_time}] Trade execution failed for {market}.")

    def close_trade(self, exit_price):
        if not isinstance(self.order, dict):
            return
        entry = self.order.get("entry_price")
        size = self.order.get("position_size", 1)
        direction = self.order.get("direction")
        market = self.order.get("market", "unknown")
        if entry is None or size == 0:
            print(f"Invalid order parameters for {market}. Order:", self.order)
            return

        profit = (exit_price - entry) * size if direction == "buy" else (entry - exit_price) * size
        self.order["profit"] = round(profit, 2)
        print(f"Trade closed at {exit_price} on {market}. Profit: {profit}. Order: {self.order}")
        update_balance(self.order.get("profit", 0))
        self.order = None

    def run(self):
        import time
        try:
            while True:
                candles = self.fetch_candles()
                market = "unknown"
                if candles and isinstance(candles, list) and isinstance(candles[-1], dict) and "market" in candles[-1]:
                    market = candles[-1]["market"]
                elif isinstance(MARKETS, dict) and MARKETS:
                    market = list(MARKETS.keys())[0]
                elif isinstance(MARKETS, list) and MARKETS:
                    market = MARKETS[0]
                print(f"[TrendBot] Checking for signal at {time.strftime('%Y-%m-%d %H:%M:%S')} for {market}")
                higher_candles = self.fetch_higher_candles() if self.fetch_higher_candles else None
                signal = self.signal_func(candles, higher_tf_candles=higher_candles)
                if signal:
                    self.enter_trade(signal, current_time=time.strftime("%Y-%m-%d %H:%M:%S"))
                time.sleep(60)
        except Exception as e:
            print(f"[TrendBot] ERROR in run loop: {e}")

if __name__ == "__main__":
    # For standalone testing. In deployment, use the launcher with CandleManager!
    TrendBot().run()


───────────────────────────────────────────────
📄 bots\wick.py
───────────────────────────────────────────────

"""
IG – Wick-reversal strategy bot (self-contained, live execution)
Now includes swing/structure filter and multi-TF confirmation.
"""

from base_bot import BaseBot
from utils.data import fetch_candles
from utils.execution import place_ig_order
from utils.indicators import atr_pips, swing_highs_lows
from utils.state import update_balance, get_balance
from config import (
    ATR_PERIOD,
    ATR_MULTIPLIER_SL,
    ATR_MULTIPLIER_TP,
    CONFIDENCE_MIN_WICK,
    WICK_RATIO,
    MARKETS,
    BOT_STRATEGY_PARAMS,
    INDICATOR_PARAMS,
    RISK_PCT
)

def wick_signal(candles, higher_tf_candles=None, signal_params=None):
    """
    Detects long-wick reversals on the most recent candle,
    with swing/structure filter and multi-TF confirmation.
    Returns a dict with trade fields or None.
    """
    if len(candles) < 2:
        return None

    bar = candles[-1]
    # Defensive: check for all required price fields
    for key in ("open", "high", "low", "close"):
        if key not in bar or bar[key] is None:
            print(f"[wick_signal] Missing or None candle value for '{key}' in {bar}. Skipping.")
            return None
    o, h, l, c = bar["open"], bar["high"], bar["low"], bar["close"]
    if not all(isinstance(v, (int, float)) for v in (o, h, l, c)):
        print(f"[wick_signal] Non-numeric OHLC in {bar}. Skipping.")
        return None
    body = abs(c - o)
    range_ = h - l
    if not isinstance(body, (int, float)) or not isinstance(range_, (int, float)) or range_ == 0:
        print(f"[wick_signal] Invalid body/range for {bar}. Skipping.")
        return None

    upper_wick = h - max(o, c)
    lower_wick = min(o, c) - l

    # FIX: Use a valid market as fallback if not present
    if "market" in bar:
        market_name = bar["market"]
    elif isinstance(MARKETS, dict) and MARKETS:
        market_name = next(iter(MARKETS.values()))
    elif isinstance(MARKETS, list) and MARKETS:
        market_name = MARKETS[0]
    else:
        market_name = "UNKNOWN"

    atr = atr_pips(candles, ATR_PERIOD)
    if atr is None or not isinstance(atr, (int, float)) or atr <= 0:
        print(f"[wick_signal] ATR unavailable or invalid for {market_name}. Skipping trade.")
        return None

    bot_cfg = BOT_STRATEGY_PARAMS.get("wick", {})
    struct_cfg = bot_cfg.get("structure_filter", {})
    swing_lookback = struct_cfg.get("lookback", INDICATOR_PARAMS.get("SWING", {}).get("lookback", 5))

    # --- Structure filter: only take reversal if near recent swing high/low ---
    swings = swing_highs_lows(candles, lookback=swing_lookback)
    swing_highs = [s['price'] for s in swings if s['type'] == 'high' and s.get('price') is not None and isinstance(s.get('price'), (int, float))]
    swing_lows = [s['price'] for s in swings if s['type'] == 'low' and s.get('price') is not None and isinstance(s.get('price'), (int, float))]
    near_swing = False

    swing_proximity = atr * 1.5  # "Near" = within 1.5 ATR of a swing high/low

    direction = None
    sl = None
    tp = None

    if lower_wick > WICK_RATIO * body and body / range_ < 0.3:
        direction = "buy"
        sl = l - ATR_MULTIPLIER_SL * atr
        tp = c + ATR_MULTIPLIER_TP * atr
        # Must be near a swing low
        if swing_lows and any(abs(l - swl) < swing_proximity for swl in swing_lows[-3:]):
            near_swing = True
    elif upper_wick > WICK_RATIO * body and body / range_ < 0.3:
        direction = "sell"
        sl = h + ATR_MULTIPLIER_SL * atr
        tp = c - ATR_MULTIPLIER_TP * atr
        # Must be near a swing high
        if swing_highs and any(abs(h - swh) < swing_proximity for swh in swing_highs[-3:]):
            near_swing = True
    else:
        return None

    # Defensive: Ensure sl/tp are not None and numeric
    if sl is None or tp is None or not isinstance(sl, (int, float)) or not isinstance(tp, (int, float)):
        print(f"[wick_signal] SL or TP could not be calculated or is not numeric for {market_name}. Skipping.")
        return None

    if not near_swing:
        print(f"[wick_signal] Skipping: not near recent swing {'low' if direction == 'buy' else 'high'}.")
        return None

    # --- Multi-timeframe confirmation (5Min + 15Min) ---
    if higher_tf_candles:
        higher_bar = higher_tf_candles[-1]
        # Defensive: check for all required price fields
        for key in ("open", "high", "low", "close"):
            if key not in higher_bar or higher_bar[key] is None:
                print(f"[wick_signal] Missing or None value in higher TF '{key}' for {market_name}. Skipping.")
                return None
        ht_o, ht_h, ht_l, ht_c = higher_bar["open"], higher_bar["high"], higher_bar["low"], higher_bar["close"]
        if not all(isinstance(v, (int, float)) for v in (ht_o, ht_h, ht_l, ht_c)):
            print(f"[wick_signal] Non-numeric OHLC in higher TF for {market_name}. Skipping.")
            return None
        ht_body = abs(ht_c - ht_o)
        ht_range = ht_h - ht_l
        if not isinstance(ht_body, (int, float)) or not isinstance(ht_range, (int, float)) or ht_range == 0:
            return None
        ht_upper_wick = ht_h - max(ht_o, ht_c)
        ht_lower_wick = min(ht_o, ht_c) - ht_l

        if direction == "buy" and not (ht_lower_wick > WICK_RATIO * ht_body and ht_body / ht_range < 0.3):
            print("[wick_signal] Skipping: no confirming bullish wick in higher TF.")
            return None
        if direction == "sell" and not (ht_upper_wick > WICK_RATIO * ht_body and ht_body / ht_range < 0.3):
            print("[wick_signal] Skipping: no confirming bearish wick in higher TF.")
            return None

    trade_signal = {
        "direction":  direction,
        "entry":      c,
        "sl":         round(sl, 2),
        "tp":         round(tp, 2),
        "confidence": bot_cfg.get("min_confidence", CONFIDENCE_MIN_WICK),
        "reason":     "wick reversal + structure + multi-TF",
        "market":     market_name,
    }

    print(f"[wick_signal] Trade signal generated: {trade_signal}")
    return trade_signal

class WickBot(BaseBot):
    def __init__(
        self, 
        name="wick", 
        signal_func=wick_signal,
        fetch_candles=fetch_candles, 
        fetch_higher_candles=None,
        place_trade=place_ig_order
    ):
        super().__init__(name, signal_func, place_trade, fetch_candles)
        self.fetch_higher_candles = fetch_higher_candles
        self.order = None

    def close_trade(self, exit_price):
        """
        Closes the trade and updates balance using only numeric profit.
        """
        if isinstance(self.order, dict):
            entry     = self.order.get("entry_price")
            size      = self.order.get("position_size", 1)
            direction = self.order.get("direction")

            if entry is not None and isinstance(size, (int, float)):
                if direction == "buy":
                    profit = (exit_price - entry) * size
                else:
                    profit = (entry - exit_price) * size
            else:
                profit = 0

            self.order["profit"] = round(profit, 2)
            print(f"Trade closed at {exit_price}. Profit: {profit}. Order: {self.order}")
            update_balance(self.order.get("profit", 0))
            self.order = None

    def enter_trade(self, trade_signal, current_time):
        """Implements trade execution for WickBot."""
        if trade_signal is None:
            return
        direction = trade_signal.get("direction")
        entry_price = trade_signal.get("entry")
        stop_loss = trade_signal.get("sl")
        take_profit = trade_signal.get("tp")
        market = trade_signal.get("market")
        confidence = trade_signal.get("confidence", CONFIDENCE_MIN_WICK)
        reason = trade_signal.get("reason", "")
        if not all([direction, entry_price, stop_loss, take_profit, market]):
            print(f"[{current_time}] Incomplete trade signal: {trade_signal}")
            return

        # Use dynamic risk as in other bots
        risk_amount = get_balance() * RISK_PCT
        sl_dist = abs(entry_price - stop_loss)
        if not isinstance(sl_dist, (int, float)) or sl_dist == 0:
            print(f"[{current_time}] ERROR: Stop loss distance is zero or invalid. Aborting trade.")
            return

        position_size = risk_amount / sl_dist

        trade = self.place_trade(
            market=market,
            direction=direction,
            size=position_size,
            sl=stop_loss,
            tp=take_profit
        )
        if trade:
            self.order = {
                "direction": direction,
                "entry_price": entry_price,
                "stop_loss": stop_loss,
                "take_profit": take_profit,
                "position_size": position_size,
                "entry_time": current_time,
                "ticket_id": trade.get("ticket_id") if isinstance(trade, dict) else None,
                "market": market,
                "confidence": confidence,
                "reason": reason,
                "trade_result": trade,
            }
            print(f"[{current_time}] Trade executed on {market}: {direction} at {entry_price} | SL: {stop_loss} | TP: {take_profit} | Size: {position_size}")
        else:
            print(f"[{current_time}] Trade execution failed.")

    def run(self):
        import time
        try:
            while True:
                print(f"[WickBot] Checking for signal at {time.strftime('%Y-%m-%d %H:%M:%S')}")
                candles = self.fetch_candles()
                higher_candles = self.fetch_higher_candles() if self.fetch_higher_candles else None
                signal = self.signal_func(candles, higher_tf_candles=higher_candles)
                if signal and isinstance(signal, dict):
                    self.enter_trade(signal, current_time=time.strftime("%Y-%m-%d %H:%M:%S"))
                time.sleep(60)
        except Exception as e:
            print(f"[WickBot] ERROR in run loop: {e}")

if __name__ == "__main__":
    # For standalone testing. In deployment, use the launcher with CandleManager!
    WickBot().run()


───────────────────────────────────────────────
📄 utils\New Text Document.txt
───────────────────────────────────────────────




───────────────────────────────────────────────
📄 utils\__init__.py
───────────────────────────────────────────────




───────────────────────────────────────────────
📄 utils\confidence.json
───────────────────────────────────────────────

85


───────────────────────────────────────────────
📄 utils\confidence.py
───────────────────────────────────────────────

"""
utils/confidence.py

Dynamic confidence scoring for trading signals based on real metrics:
- Signal strength (indicator distance, breakout magnitude, wick size, etc)
- Volatility regime (ATR percentile or standard deviation)
- Multi-indicator/model agreement (how many signals align)
- Historical edge (optional: winrate, sharpe, expectancy of similar signals)
- Market context (optional: volume surge, time of day, etc)

Each bot may supply its own weights or input types for these.
"""

import numpy as np

def normalize(value, min_value, max_value):
    """Normalize a value between 0 and 1."""
    if max_value == min_value:
        return 0.5  # avoid div by zero
    return max(0.0, min(1.0, (value - min_value) / (max_value - min_value)))

def confidence_signal_strength(val, minval, maxval):
    """
    Normalize a signal strength metric (distance from EMA, breakout size, etc) to 0-1.
    """
    return normalize(val, minval, maxval)

def confidence_volatility(current_atr, atr_lookback):
    """
    Score volatility regime: higher volatility may increase or decrease confidence depending on strategy.
    Returns normalized ATR percentile (0=low, 1=high).
    """
    arr = np.array(atr_lookback)
    if len(arr) < 2:
        return 0.5
    percentile = (arr < current_atr).sum() / len(arr)
    return percentile  # 0=low, 1=high

def confidence_agreement(signals: list, required: int = 2):
    """
    Returns confidence boost if multiple models/indicators agree (0-1).
    E.g., RSI and EMA agree = 1, only one = 0.
    """
    agreeing = sum(1 for s in signals if s)
    return min(1.0, agreeing / required)

def confidence_historical(winrate: float, min_wr=0.4, max_wr=0.75):
    """
    Normalize historical winrate to 0-1, using reasonable bounds.
    """
    return normalize(winrate, min_wr, max_wr)

def calculate_confidence(
    signal_strength: float,  # 0–1 (normalized)
    volatility: float,       # 0–1 (normalized)
    agreement: float,        # 0–1 (normalized)
    winrate: float = 0.5,    # 0–1 (normalized, optional)
    weights: dict = None,
):
    """
    Main interface: returns integer 0–100 confidence.
    weights can override default importance of each component.
    """
    # Default weights: signal strength = 40%, volatility = 20%, agreement = 20%, winrate = 20%
    weights = weights or dict(signal=0.4, vol=0.2, agree=0.2, win=0.2)
    score = (
        weights['signal'] * signal_strength +
        weights['vol']    * volatility +
        weights['agree']  * agreement +
        weights['win']    * winrate
    )
    return int(round(100 * score))


# Example usage in a bot signal function:
#
# from utils.confidence import (
#     confidence_signal_strength, confidence_volatility,
#     confidence_agreement, confidence_historical, calculate_confidence
# )
#
# distance_from_ema = abs(price - ema21)
# signal_strength = confidence_signal_strength(distance_from_ema, 0, 2)   # e.g., 0–2% of price
# volatility = confidence_volatility(current_atr, atr_lookback)
# agreement = confidence_agreement([ema_trend, rsi_trend], 2)
# winrate = confidence_historical(backtest_winrate)  # e.g., 0.62
#
# confidence = calculate_confidence(
#     signal_strength=signal_strength,
#     volatility=volatility,
#     agreement=agreement,
#     winrate=winrate,
#     weights=dict(signal=0.5, vol=0.1, agree=0.2, win=0.2)  # Custom for this bot
# )
#
# trade_signal = {"confidence": confidence, ...}


───────────────────────────────────────────────
📄 utils\controller.py
───────────────────────────────────────────────

# utils/controller.py
import threading
from datetime import datetime, time as dtime
import pytz
from config import LONDON_TZ

run_event = threading.Event()

def in_restricted_time(bot_name: str) -> bool:
    """
    Returns True if the bot should be paused:
    - All bots pause during 08:00–08:30 and 13:30–14:00 (London time)
    - All bots except 'scalping' pause outside 08:00–17:00
    """
    try:
        now = datetime.now(pytz.timezone(LONDON_TZ)).time()
    except Exception as e:
        print(f"[controller] Timezone error: {e}")
        return True  # fail-safe to block trading if clock breaks

    # Opening windows (30-min post-open cooldowns)
    london_open     = dtime(8, 0)
    london_block    = dtime(8, 30)

    ny_open         = dtime(13, 30)
    ny_block        = dtime(14, 0)

    in_open_window = (london_open <= now < london_block) or (ny_open <= now < ny_block)

    # Full session window for standard bots
    session_start   = dtime(8, 0)
    session_end     = dtime(17, 0)
    in_session      = session_start <= now <= session_end

    if bot_name.lower() == "scalping":
        return in_open_window  # scalping ignores full session hours
    else:
        return in_open_window or not in_session


───────────────────────────────────────────────
📄 utils\correlation.py
───────────────────────────────────────────────

# utils/correlation.py
def compute_correlation(data1,data2):
    return 0.0



───────────────────────────────────────────────
📄 utils\data.py
───────────────────────────────────────────────

"""
utils/data.py – Universal candle-fetcher wrapper.
Enhanced for multi-timeframe and batch fetching.
Robust to varying IG API formats and ready for extension to new brokers/data sources.
Amended: Always requires valid IG session tokens for REST API calls.
"""

import requests
from config import IG_API_BASE_URL, DEBUG_MODE

# Import the IGSession class
from utils.session import IGSession

# --- Timeframe mapping for IG REST API ---
TF_MAP = {
    "1MIN": "MINUTE",
    "1Min": "MINUTE",
    "MINUTE": "MINUTE",
    "5MIN": "MINUTE_5",
    "5Min": "MINUTE_5",
    "15MIN": "MINUTE_15",
    "15Min": "MINUTE_15",
    "30MIN": "MINUTE_30",
    "30Min": "MINUTE_30",
    "1H": "HOUR",
    "1HOUR": "HOUR",
    "1Hour": "HOUR",
    "HOUR": "HOUR",
    "DAILY": "DAY",
    "DAY": "DAY",
    "WEEKLY": "WEEK",
    "WEEK": "WEEK",
    "MONTHLY": "MONTH",
    "MONTH": "MONTH"
}

def map_timeframe(tf):
    """Map internal timeframe to IG REST API format."""
    tfu = tf.upper()
    if tfu in TF_MAP:
        return TF_MAP[tfu]
    # Try to parse "MINUTE_X" format
    if tfu.startswith("MINUTE"):
        return tfu
    # fallback: IG may support as-is
    return tf

# Define safe defaults supported by the IG API.
DEFAULT_RESOLUTION = "HOUR"       # Instead of "1Min"
DEFAULT_NUM_CANDLES = 200

def fetch_candles(session: IGSession, market: str, timeframe: str = DEFAULT_RESOLUTION, num: int = DEFAULT_NUM_CANDLES, *args, **kwargs):
    """
    Fetch candles for a given market and timeframe using an authenticated IGSession.
    Allows overriding of timeframe and count via keyword arguments.
    If no resolution is provided, it now defaults to "HOUR".
    Returns list of dicts: [{"time", "open", "high", "low", "close", "volume"}...]
    """
    timeframe = kwargs.get("resolution", timeframe)
    num = kwargs.get("count", kwargs.get("num", num))
    timeframe_ig = map_timeframe(timeframe)
    return _fetch_candles_ig_rest(session, market, timeframe_ig, num)

def _fetch_candles_ig_rest(session: IGSession, market: str, timeframe: str, num: int):
    """
    Fetch candles from IG REST API using session tokens.
    Handles both "prices" and "candles" key, and includes volume if present.
    """
    url = f"{IG_API_BASE_URL}/prices/{market}?resolution={timeframe}&max={num}"
    headers = session.get_headers()
    response = requests.get(url, headers=headers, timeout=10)
    response.raise_for_status()
    data = response.json()
    prices = data.get("prices") or data.get("candles")
    candles = []
    for bar in prices:
        # Some IG endpoints use ...Price["ask"], others use ...Price["mid"]
        open_ = bar.get("openPrice", {}).get("ask") or bar.get("openPrice", {}).get("mid")
        high_ = bar.get("highPrice", {}).get("ask") or bar.get("highPrice", {}).get("mid")
        low_  = bar.get("lowPrice", {}).get("ask") or bar.get("lowPrice", {}).get("mid")
        close_= bar.get("closePrice", {}).get("ask") or bar.get("closePrice", {}).get("mid")
        volume = bar.get("lastTradedVolume", None) or bar.get("volume", None)
        candles.append({
            "time": bar.get("snapshotTime") or bar.get("timestamp"),
            "open": open_,
            "high": high_,
            "low":  low_,
            "close": close_,
            "volume": volume if volume is not None else 0.0
        })
    return candles

def fetch_multi_timeframe_candles(session: IGSession, market: str, resolutions: list, num: int = DEFAULT_NUM_CANDLES):
    """
    Fetch candles for multiple timeframes for a single market.
    Returns a dict keyed by resolution.
    Example: resolutions = ["5MIN", "1HOUR"]
    """
    result = {}
    for tf in resolutions:
        try:
            result[tf] = fetch_candles(session, market, tf, num)
        except Exception as e:
            print(f"[data.py] Failed to fetch {tf} candles for {market}: {e}")
            result[tf] = []
    return result

def fetch_batch_candles(session: IGSession, markets: list, timeframe: str = DEFAULT_RESOLUTION, num: int = DEFAULT_NUM_CANDLES):
    """
    Fetch candles for multiple markets in parallel for a given timeframe.
    Returns a dict keyed by market.
    """
    result = {}
    for m in markets:
        try:
            result[m] = fetch_candles(session, m, timeframe, num)
        except Exception as e:
            print(f"[data.py] Failed to fetch candles for {m}: {e}")
            result[m] = []
    return result

# --- Advanced: Smart multi-TF cache (optional) -------------------------
# You could extend this with a caching layer so that if multiple bots
# request the same market/TF/period, you only fetch once per run.

# --- Advanced: Timezone handling ---------------------------------------
# If you wish to align candles with session windows, you can parse
# "time" to datetime and adjust for Europe/London etc.

# Example usage:
# ig_session = IGSession()
# ig_session.login()
# candles_5m_1h = fetch_multi_timeframe_candles(ig_session, "IX.D.NASDAQ.CASH.IP", ["MINUTE_5", "HOUR"], 200)
# batch = fetch_batch_candles(ig_session, ["IX.D.NASDAQ.CASH.IP", "IX.D.SUNDAX.DAILY.IP"], "MINUTE_5", 200)


───────────────────────────────────────────────
📄 utils\data_fetcher.py
───────────────────────────────────────────────

# utils/data_fetcher.py
import requests, os, json
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD

LOGIN_ENDPOINT = f"{IG_API_BASE_URL}/session"

def get_session() -> requests.Session:
    """Login to IG, return an authorised Session."""
    s = requests.Session()
    s.headers.update({
        "X-IG-API-KEY": IG_APP_KEY,
        "Content-Type": "application/json; charset=UTF-8",
        "Accept": "application/json; charset=UTF-8"
    })
    payload = {
        "identifier": IG_USERNAME,
        "password":   IG_PASSWORD
    }
    r = s.post(LOGIN_ENDPOINT, json=payload)
    r.raise_for_status()
    oauth = r.json()
    cst = r.headers["CST"]
    sst = r.headers["X-SECURITY-TOKEN"]
    s.headers.update({"CST": cst, "X-SECURITY-TOKEN": sst})
    return s


───────────────────────────────────────────────
📄 utils\emailer.py
───────────────────────────────────────────────

# utils/emailer.py
"""Outbound e-mail utilities for Trade Command Monarch.

Features
--------
• Auto-detect TLS (587) vs SSL (465)
• Graceful no-op when SMTP creds are absent
• Multipart (plain + HTML)
• Helpers: trade placed/closed, bot online/offline, daily & weekly summaries
"""

import logging, smtplib, ssl
from email.message import EmailMessage
from datetime import datetime
import pytz

from config import (
    SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS,
    TRADE_ALERT_EMAIL, MARKETS, LONDON_TZ
)
from utils.journal import read_daily_pnl

# ──────────────────────────────────────────────────────────
# constants
# ──────────────────────────────────────────────────────────
SMTP_CONFIG = dict(
    host=SMTP_HOST or "",
    port=int(SMTP_PORT or 0),
    user=SMTP_USER or "",
    pwd = SMTP_PASS or "",
)

RECIPIENTS = [e.strip() for e in TRADE_ALERT_EMAIL.split(",") if e.strip()]
LONDON     = pytz.timezone(LONDON_TZ)

# ──────────────────────────────────────────────────────────
# core sender
# ──────────────────────────────────────────────────────────
def _send_email(subject: str, text: str, html: str | None = None) -> None:
    """Push a multipart message; skip quietly if SMTP not configured."""
    if not (SMTP_CONFIG["host"] and SMTP_CONFIG["port"]
            and SMTP_CONFIG["user"] and SMTP_CONFIG["pwd"] and RECIPIENTS):
        logging.warning("[emailer] SMTP not configured – \"%s\" suppressed", subject)
        return

    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"]    = SMTP_CONFIG["user"]
    msg["To"]      = ", ".join(RECIPIENTS)
    msg.set_content(text)
    if html:
        msg.add_alternative(html, subtype="html")

    try:
        if SMTP_CONFIG["port"] == 465:          # implicit SSL
            context = ssl.create_default_context()
            with smtplib.SMTP_SSL(SMTP_CONFIG["host"], 465, context=context) as s:
                s.login(SMTP_CONFIG["user"], SMTP_CONFIG["pwd"])
                s.send_message(msg)
        else:                                   # default: start-TLS
            with smtplib.SMTP(SMTP_CONFIG["host"], SMTP_CONFIG["port"]) as s:
                s.starttls()
                s.login(SMTP_CONFIG["user"], SMTP_CONFIG["pwd"])
                s.send_message(msg)
        logging.info("[emailer] sent \"%s\"", subject)
    except Exception as exc:
        logging.error("[emailer] failed \"%s\": %s", subject, exc, exc_info=True)

# ──────────────────────────────────────────────────────────
# helpers
# ──────────────────────────────────────────────────────────
def _weekday_london() -> bool:
    return datetime.now(LONDON).weekday() < 5

# ---------- trade placed ----------
def send_trade_placed_email(market, direction, size, sl, tp, confidence, strategy):
    subj  = f"[Monarch] New {strategy} trade on {market}"
    entry = (sl + tp) / 2
    text  = (
        "Hi Adrian,\n\n"
        f"We placed a {strategy} {direction} trade on {market}.\n"
        f"Size: £{size}  Entry: {entry:.2f}  SL: {sl}  TP: {tp}\n"
        f"Confidence: {confidence}/100\n\nGood luck!\n— TCM"
    )
    html  = f"""
    <p>Hi Adrian,</p>
    <p>We placed a <b>{strategy}</b> <b>{direction}</b> trade on <b>{market}</b>.</p>
    <ul>
      <li>Size: £{size}</li><li>Entry: {entry:.2f}</li>
      <li>Stop-Loss: {sl}</li><li>Take-Profit: {tp}</li>
      <li>Confidence: {confidence}/100</li>
    </ul>
    <p>Good luck! — TCM</p>
    """
    _send_email(subj, text, html)

# ---------- trade closed (fixed) ----------
def send_trade_outcome_email(market, direction, entry_price, exit_price, profit):
    won           = profit >= 0
    outcome_txt   = "in profit" if won else "at a loss"
    label         = "Profit" if won else "Loss"
    flair         = "Great job!" if won else "On to the next."
    subj          = f"[Monarch] Trade {'WIN' if won else 'loss'} on {market}"

    text = (
        "Hi Adrian,\n\n"
        f"Your {direction} trade on {market} closed {outcome_txt}.\n"
        f"Entry: {entry_price}\nExit:  {exit_price}\n"
        f"{label}: £{abs(profit):.2f}\n\n{flair} — TCM"
    )

    html = f"""
    <p>Hi Adrian,</p>
    <p>Your <b>{direction}</b> trade on <b>{market}</b> closed
       <b>{outcome_txt}</b>.</p>
    <ul>
      <li>Entry: {entry_price}</li>
      <li>Exit:  {exit_price}</li>
      <li>{label}: £{abs(profit):.2f}</li>
    </ul>
    <p>{flair} — TCM</p>
    """

    _send_email(subj, text, html)

# ---------- bots online / offline ----------
def send_bot_online_email():
    if _weekday_london():
        subj = "[Monarch] Bots ONLINE"
        _send_email(subj,
                    "Hi Adrian,\n\nBots started.\n— TCM",
                    f"<p>Bots started. Monitoring: {', '.join(MARKETS)}</p>")

def send_bot_offline_email():
    if _weekday_london():
        subj = "[Monarch] Bots OFFLINE"
        _send_email(subj,
                    "Hi Adrian,\n\nBots stopped.\n— TCM",
                    "<p>Bots stopped. See you next session!</p>")

# ---------- crash ----------
def send_crash_email(error_message):
    _send_email("[Monarch] Bot exception", str(error_message))

# ---------- summaries ----------
def send_daily_summary_email():
    if not _weekday_london(): return
    now = datetime.now(LONDON).strftime("%Y-%m-%d")
    _send_email(f"[Monarch] Daily summary {now}", read_daily_pnl())

def send_weekly_summary_email():
    now = datetime.now(LONDON).strftime("%Y-%m-%d")
    _send_email(f"[Monarch] Weekly summary {now}", read_daily_pnl())  # TODO: weekly agg


───────────────────────────────────────────────
📄 utils\execution.py
───────────────────────────────────────────────

"""
utils/execution.py - Live IG order placement with Spread Betting support + robust session and client-token handling
Now with confirmation polling (as robust as your working test bot).
"""

import requests
import time
from typing import Optional

from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID, DEBUG_MODE
from utils.trade_executor import get_live_ig_balance
from utils.session import IGSession

# --- IGSession Management ---
# Create ONE persistent IGSession instance (shared by all calls)
_ig_session = None

def get_ig_session():
    """
    Ensures a single IGSession instance is used and logged in.
    """
    global _ig_session
    if _ig_session is None:
        _ig_session = IGSession()
        _ig_session.login()
    else:
        _ig_session.ensure_logged_in()
    return _ig_session

def place_ig_order(market: str, direction: str, size: float, sl: float, tp: float, **kwargs):
    """
    Sends a MARKET order to IG. Returns confirmation status as well.
    """
    return _ig_rest_place(market, direction, size, sl, tp)

place_trade = place_ig_order

def _ig_rest_place(market: str, direction: str, size: float, sl: float, tp: float, **kwargs):
    ig_session = get_ig_session()
    tokens = {"CST": ig_session.cst, "X-SECURITY-TOKEN": ig_session.security_token}

    endpoint = "positions/otc"
    payload = {
        "epic": market,
        "expiry": "-",  # Use "-" for non-expiry markets (spreadbets)
        "direction": direction.upper(),
        "size": str(size),
        "orderType": "MARKET",
        "timeInForce": "FILL_OR_KILL",
        "currencyCode": "GBP",
        "forceOpen": True,
        "guaranteedStop": False,
        "stopLevel": float(sl),
        "limitLevel": float(tp)
    }

    url = f"{IG_API_BASE_URL}/{endpoint}"
    print("DEBUG: Market epic:", market, "using endpoint:", url)
    print("DEBUG: Sending order payload:", payload)

    # Try to add the client-token from cookies if set
    client_token = None
    for c in ig_session.session.cookies:
        if c.name == 'client-token':
            client_token = c.value
    headers = ig_session.get_headers({
        "Version": "2",
        "Accept": "application/json",
        "Content-Type": "application/json"
    })
    if client_token:
        headers["client-token"] = client_token

    try:
        response = ig_session.session.post(url, headers=headers, json=payload, timeout=10)
        response.raise_for_status()
        data = response.json()
        deal_ref = data.get("dealReference")
        deal_id = data.get("dealId", "")

        # --- Confirmation polling ---
        confirm_json = {}
        confirmed_status = None
        if deal_ref:
            confirm_url = f"{IG_API_BASE_URL}/confirms/{deal_ref}"
            for _ in range(5):
                conf_resp = ig_session.session.get(confirm_url, headers=headers, timeout=10)
                if conf_resp.status_code == 200:
                    confirm_json = conf_resp.json()
                    confirmed_status = confirm_json.get("dealStatus")
                    if confirmed_status and confirmed_status.lower() in ("accepted", "rejected"):
                        break
                time.sleep(1)
        live_balance = get_live_ig_balance(ig_session)
        return {
            "entry": deal_ref,
            "ticket_id": deal_id,
            "pnl": 0.0,
            "balance": live_balance,
            "error": None if confirmed_status == "ACCEPTED" else f"Order not confirmed: {confirmed_status}",
            "confirmation": confirm_json
        }
    except requests.exceptions.HTTPError as e:
        print("IG ORDER ERROR:", response.text)
        return {
            "entry": None,
            "ticket_id": None,
            "pnl": 0.0,
            "balance": 0.0,
            "error": str(e) + " | IG: " + response.text,
            "confirmation": {}
        }


───────────────────────────────────────────────
📄 utils\file_utils.py
───────────────────────────────────────────────

# utils/file_utils.py
import json, shutil, tempfile, os

def atomic_write_json(data: dict, path: str):
    """
    Write JSON atomically so bots never read a half-written file.
    Works on Windows (NTFS) and Linux.
    """
    folder = os.path.dirname(path) or "."
    with tempfile.NamedTemporaryFile("w", delete=False, dir=folder) as tmp:
        json.dump(data, tmp)
    shutil.move(tmp.name, path)          # atomic rename


───────────────────────────────────────────────
📄 utils\filters.py
───────────────────────────────────────────────

from datetime import datetime
from pytz import timezone
import numpy as np

from config import (
    MOMENTUM_THRESHOLD, WICK_RATIO, CONFIDENCE_MIN_MOMENTUM, CONFIDENCE_MIN_WICK,
    LONDON_TZ
)

from utils.controller import in_restricted_time  # Central time logic now used here


# ── Individual Filter Logic ─────────────────────────────────────────────

def volatility_filter(atr, min_atr=0.5, max_atr=20):
    return min_atr < atr < max_atr

def momentum_filter(momentum):
    return abs(momentum) > MOMENTUM_THRESHOLD

def wick_filter(wick_ratio):
    return wick_ratio > WICK_RATIO

def exposure_filter(state, bot, max_trades):
    open_trades = state.get_open_trades(bot)
    return len(open_trades) < max_trades

def multi_timeframe_trend_filter(curr_tf_trend, higher_tf_trend):
    return curr_tf_trend == higher_tf_trend

def confidence_score(signal):
    """
    Assigns confidence score (1–100) based on signal fields.
    Fields: 'momentum', 'wick_ratio', 'trend_agreement', 'atr'
    """
    score = 50
    score += min(30, abs(signal.get("momentum", 0)) * 100 / MOMENTUM_THRESHOLD) \
        if abs(signal.get("momentum", 0)) > MOMENTUM_THRESHOLD else 0
    score += 10 if signal.get("wick_ratio", 0) > WICK_RATIO else 0
    score += 10 if signal.get("trend_agreement", False) else 0

    atr = signal.get("atr", 0)
    if 1 < atr < 10:
        score += 5
    elif atr < 0.5 or atr > 20:
        score -= 10

    return max(1, min(100, int(score)))


# ── Composite Signal Gate ───────────────────────────────────────────────

def filter_signal(signal, state, bot, max_trades, now=None):
    """
    Applies all filters and returns dict:
    {
        'passed': bool,
        'confidence': int,
        'explanation': str
    }
    """
    reasons = []

    # Time filter (centralized to controller.py)
    if in_restricted_time(bot):
        reasons.append("Restricted trading window (e.g. session closed or market open cooldown)")

    if not volatility_filter(signal.get("atr", 0)):
        reasons.append("ATR volatility out of range.")
    if not momentum_filter(signal.get("momentum", 0)):
        reasons.append("Momentum too low.")
    if not wick_filter(signal.get("wick_ratio", 0)):
        reasons.append("Wick ratio too low.")
    if not exposure_filter(state, bot, max_trades):
        reasons.append("Max open trades for bot reached.")
    if not multi_timeframe_trend_filter(signal.get("trend"), signal.get("trend_higher")):
        reasons.append("Trend mismatch with higher timeframe.")

    conf = confidence_score(signal)

    return {
        "passed": len(reasons) == 0,
        "confidence": conf,
        "explanation": "; ".join(reasons) if reasons else "All filters passed."
    }


# ── Signal Placeholders (can be removed in prod if defined elsewhere) ──

def trend_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 0),
        "wick_ratio": signal_params.get("wick_ratio", 0),
        "trend": "up",
        "trend_higher": "up",
        "atr": signal_params.get("atr", 1.5),
        "trend_agreement": True
    }

def meanreversion_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 0),
        "wick_ratio": signal_params.get("wick_ratio", 0),
        "trend": "down",
        "trend_higher": "down",
        "atr": signal_params.get("atr", 1.2),
        "trend_agreement": True
    }

meanrev_signal = meanreversion_signal

def wick_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 0),
        "wick_ratio": signal_params.get("wick_ratio", 2.1),
        "trend": "up",
        "trend_higher": "up",
        "atr": signal_params.get("atr", 0.9),
        "trend_agreement": True
    }

def breakout_signal(candles, higher_tf_candles, signal_params):
    return {
        "momentum": signal_params.get("momentum", 1.8),
        "wick_ratio": signal_params.get("wick_ratio", 0.7),
        "trend": "up",
        "trend_higher": "up",
        "atr": signal_params.get("atr", 2.2),
        "trend_agreement": True
    }


───────────────────────────────────────────────
📄 utils\health_check.py
───────────────────────────────────────────────

import time
import json
import os
from utils.stream_fetcher import start_streaming
from utils.filters import momentum_logic_passed, wick_rejection_logic_passed, trend_continuation_logic_passed

CONFIDENCE_FILE = "confidence.json"
DEFAULT_CONFIDENCE = 85  # Default confidence for trades

def check_health():
    """
    Checks the health of the system (e.g., if bots are alive).
    """
    print("Checking system health...")

def get_confidence_threshold():
    """
    Fetch the current global confidence threshold from confidence.json (dashboard slider).
    """
    if not os.path.exists(CONFIDENCE_FILE):
        set_confidence_threshold(DEFAULT_CONFIDENCE)
        return DEFAULT_CONFIDENCE
    try:
        with open(CONFIDENCE_FILE, "r") as f:
            data = json.load(f)
            return int(data.get("confidence", DEFAULT_CONFIDENCE))
    except Exception:
        return DEFAULT_CONFIDENCE

def set_confidence_threshold(value):
    """
    Set the global confidence threshold for bots and persist to confidence.json.
    """
    try:
        with open(CONFIDENCE_FILE, "w") as f:
            json.dump({"confidence": int(value)}, f)
    except Exception:
        pass  # Optionally add logging here

def record_bot_heartbeat(bot_name):
    """
    Record heartbeat for each bot (used for monitoring).
    """
    print(f"❤️ {bot_name} heartbeat recorded!")

def update_confidence_threshold(new_threshold):
    """
    Update the confidence threshold in the system.
    """
    set_confidence_threshold(new_threshold)
    print(f"✅ Updated confidence threshold to {new_threshold}")


───────────────────────────────────────────────
📄 utils\ig_account.py
───────────────────────────────────────────────

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID, IG_USERNAME, IG_PASSWORD

def ig_login():
    """Login to IG and return headers with session tokens."""
    url = f"{IG_API_BASE_URL}/session"
    data = {
        "identifier": IG_USERNAME,
        "password": IG_PASSWORD
    }
    headers = {
        "X-IG-API-KEY": IG_APP_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    resp = requests.post(url, json=data, headers=headers)
    resp.raise_for_status()
    resp_headers = resp.headers
    security_token = resp_headers.get("X-SECURITY-TOKEN")
    cst_token = resp_headers.get("CST")
    headers.update({
        "X-SECURITY-TOKEN": security_token,
        "CST": cst_token,
        "Version": "2"
    })
    return headers

def get_ig_account_balance():
    """Fetch live account balance from IG."""
    headers = ig_login()
    url = f"{IG_API_BASE_URL}/accounts"
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    accounts = resp.json()["accounts"]
    for acc in accounts:
        if acc["accountId"] == IG_ACCOUNT_ID:
            return float(acc["balance"]["available"])
    raise Exception("IG account ID not found.")


───────────────────────────────────────────────
📄 utils\ig_auth.py
───────────────────────────────────────────────

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD

class IGSession:
    """
    IGSession handles authentication and holds CST/X-SECURITY-TOKEN for all requests.
    Call IGSession.login() first and then use get_headers() for all subsequent IG API calls.
    """
    def __init__(self):
        self.session = requests.Session()
        self.cst = None
        self.security_token = None

    def login(self):
        url = f"{IG_API_BASE_URL}/session"
        headers = {
            "X-IG-API-KEY": IG_APP_KEY,
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
        payload = {
            "identifier": IG_USERNAME,
            "password": IG_PASSWORD
        }
        resp = self.session.post(url, headers=headers, json=payload, timeout=10)
        print("[IG_LOGIN] Status Code:", resp.status_code)
        print("[IG_LOGIN] Response Headers:", dict(resp.headers))
        try:
            json_response = resp.json()
            print("[IG_LOGIN] JSON Response:", json_response)
        except Exception as e:
            print("[IG_LOGIN] No valid JSON response:", e)
            json_response = {}

        resp.raise_for_status()
        self.cst = resp.headers.get("CST")
        self.security_token = resp.headers.get("X-SECURITY-TOKEN")
        print("[IG_LOGIN] Tokens received:", {"CST": self.cst, "X-SECURITY-TOKEN": self.security_token})
        if not self.cst or not self.security_token:
            raise Exception("IG login succeeded but tokens missing in response headers")
        return self.cst, self.security_token

    def get_headers(self, extra_headers=None):
        """
        Returns all headers required for authenticated IG API requests.
        Optionally add/override with extra_headers dict.
        """
        if not self.cst or not self.security_token:
            raise Exception("IGSession not logged in yet! Call login() first.")
        headers = {
            "X-IG-API-KEY": IG_APP_KEY,
            "CST": self.cst,
            "X-SECURITY-TOKEN": self.security_token,
            "Accept": "application/json",
            "Version": "3"
        }
        if extra_headers:
            headers.update(extra_headers)
        return headers

    def ensure_logged_in(self):
        """
        Convenience: Login if no tokens currently set.
        """
        if not self.cst or not self.security_token:
            self.login()

# --- Example standalone usage (for testing) ---
if __name__ == "__main__":
    ig = IGSession()
    ig.login()
    print("Logged in. Auth headers for subsequent requests:", ig.get_headers())


───────────────────────────────────────────────
📄 utils\indicators.py
───────────────────────────────────────────────

"""
utils/indicators.py
Light-weight technical indicators with ZERO external dependencies (pure Python).
If you later install pandas/numpy/ta-lib, you can swap in faster versions.
All indicators return both a SERIES (for feature engineering/confidence) and a LAST value (for signals).
"""

import statistics
from typing import List, Dict, Optional

# ---------------------------------------------------------------------------
#  Helper: true range
# ---------------------------------------------------------------------------
def _true_range(curr: Dict, prev_close: float) -> float:
    """
    True Range for one candle.
    `curr` = dict with 'high', 'low', 'close'.
    """
    return max(
        curr["high"] - curr["low"],
        abs(curr["high"] - prev_close),
        abs(curr["low"] - prev_close),
    )

# ---------------------------------------------------------------------------
#  ATR in pips (or points) – PURE PYTHON
# ---------------------------------------------------------------------------
def atr_pips(candles: List[Dict], lookback: int = 14) -> float:
    """
    Return Average True Range for the last `lookback` candles.
    """
    if len(candles) < lookback + 1:
        return 1.0  # safety fallback
    trs = []
    for i in range(1, lookback + 1):
        tr = _true_range(candles[-i], candles[-i-1]["close"])
        trs.append(tr)
    return round(statistics.mean(trs), 4) or 1.0

def atr_series(candles: List[Dict], period: int = 14) -> List[float]:
    """
    Calculate ATR series (for confidence/volatility regime).
    """
    if len(candles) < period + 1:
        return [1.0] * len(candles)
    atrs = []
    for i in range(period, len(candles)):
        trs = [_true_range(candles[j], candles[j-1]["close"]) for j in range(i-period+1, i+1)]
        atrs.append(statistics.mean(trs))
    return atrs

# ---------------------------------------------------------------------------
#  EMA – Exponential Moving Average
# ---------------------------------------------------------------------------
def ema_series(values: List[float], period: int = 20) -> List[float]:
    """
    Exponential moving average as a full series.
    """
    if not values or len(values) < period:
        return [values[-1]] * len(values) if values else []
    ema_vals = []
    k = 2 / (period + 1)
    ema_prev = sum(values[:period]) / period  # SMA for seed
    ema_vals = [None] * (period - 1) + [ema_prev]
    for v in values[period:]:
        ema_new = v * k + ema_prev * (1 - k)
        ema_vals.append(ema_new)
        ema_prev = ema_new
    return ema_vals

def ema(values: List[float], period: int = 20) -> float:
    """Return latest EMA value."""
    series = ema_series(values, period)
    return series[-1] if series else 0.0

# ---------------------------------------------------------------------------
#  SMA – Simple Moving Average
# ---------------------------------------------------------------------------
def sma_series(values: List[float], period: int = 20) -> List[Optional[float]]:
    """
    Simple moving average as a full series.
    """
    if not values or len(values) < period:
        return [values[-1]] * len(values) if values else []
    sma_vals = []
    for i in range(len(values)):
        if i+1 < period:
            sma_vals.append(None)
        else:
            sma_vals.append(statistics.mean(values[i+1-period:i+1]))
    return sma_vals

def sma(values: List[float], period: int = 20) -> float:
    series = sma_series(values, period)
    return series[-1] if series else 0.0

# ---------------------------------------------------------------------------
#  RSI – Relative Strength Index
# ---------------------------------------------------------------------------
def rsi_series(values: List[float], period: int = 14) -> List[float]:
    """
    RSI as a full series. Returns 0-100.
    """
    if len(values) < period + 1:
        return [50.0] * len(values)
    rsis = [None] * period
    gains = []
    losses = []
    for i in range(1, period + 1):
        change = values[i] - values[i-1]
        (gains if change > 0 else losses).append(abs(change))
    avg_gain = sum(gains) / period if gains else 0.0
    avg_loss = sum(losses) / period if losses else 0.0
    rs = avg_gain / avg_loss if avg_loss != 0 else 0
    rsis.append(100 - 100 / (1 + rs) if avg_loss != 0 else 100)
    for i in range(period + 1, len(values)):
        change = values[i] - values[i-1]
        gain = max(change, 0)
        loss = abs(min(change, 0))
        avg_gain = (avg_gain * (period - 1) + gain) / period
        avg_loss = (avg_loss * (period - 1) + loss) / period
        rs = avg_gain / avg_loss if avg_loss != 0 else 0
        rsis.append(100 - 100 / (1 + rs) if avg_loss != 0 else 100)
    return rsis

def rsi(values: List[float], period: int = 14) -> float:
    series = rsi_series(values, period)
    return series[-1] if series else 50.0

# ---------------------------------------------------------------------------
#  Donchian Channel (returns upper, lower, and mid lines)
# ---------------------------------------------------------------------------
def donchian_channel(candles: List[Dict], period: int = 20) -> Dict[str, float]:
    """
    Returns upper, lower, and mid lines for latest window.
    """
    if len(candles) < period:
        highs = [c["high"] for c in candles]
        lows = [c["low"] for c in candles]
    else:
        highs = [c["high"] for c in candles[-period:]]
        lows = [c["low"] for c in candles[-period:]]
    upper = max(highs) if highs else 0.0
    lower = min(lows) if lows else 0.0
    mid = (upper + lower) / 2 if highs and lows else 0.0
    return {"upper": upper, "lower": lower, "mid": mid}

# ---------------------------------------------------------------------------
#  Stochastic Oscillator
# ---------------------------------------------------------------------------
def stoch_osc(candles: List[Dict], k_period: int = 14, d_period: int = 3) -> Dict[str, float]:
    """
    Returns latest %K and %D.
    """
    if len(candles) < k_period:
        return {"%K": 50.0, "%D": 50.0}
    closes = [c["close"] for c in candles]
    highs = [c["high"] for c in candles[-k_period:]]
    lows = [c["low"] for c in candles[-k_period:]]
    highest_high = max(highs)
    lowest_low = min(lows)
    last_close = closes[-1]
    k = 100 * (last_close - lowest_low) / (highest_high - lowest_low) if highest_high != lowest_low else 50.0
    # D = SMA of K
    k_values = []
    for i in range(d_period):
        idx = -1 - i
        if len(closes) + idx < 0:
            k_values.append(k)
        else:
            window = closes[idx - k_period + 1: idx + 1] if idx - k_period + 1 >= -len(closes) else closes[:idx + 1]
            window_high = max([candles[j]["high"] for j in range(len(candles) + idx - k_period + 1, len(candles) + idx + 1)]) if window else highest_high
            window_low = min([candles[j]["low"] for j in range(len(candles) + idx - k_period + 1, len(candles) + idx + 1)]) if window else lowest_low
            k_val = 100 * (closes[idx] - window_low) / (window_high - window_low) if window_high != window_low else 50.0
            k_values.append(k_val)
    d = sum(k_values) / len(k_values) if k_values else 50.0
    return {"%K": k, "%D": d}

# ---------------------------------------------------------------------------
#  VWAP – Volume Weighted Average Price (stub, extend if you have volume)
# ---------------------------------------------------------------------------
def vwap(candles: List[Dict]) -> float:
    """
    Calculate VWAP if volume is present in candle dicts.
    """
    total_vol = sum(c.get("volume", 0.0) for c in candles)
    if total_vol == 0:
        return sum(c["close"] for c in candles) / len(candles) if candles else 0.0
    return sum(c["close"] * c.get("volume", 0.0) for c in candles) / total_vol

# ---------------------------------------------------------------------------
#  ADX – Average Directional Index (Trend Strength Regime Filter)
# ---------------------------------------------------------------------------
def adx(candles: List[Dict], period: int = 14) -> List[Optional[float]]:
    """
    Calculate ADX (Average Directional Index) as a series.
    Returns list of ADX values (None for warmup period), last value is most recent.
    """
    if len(candles) < period + 1:
        return [None] * len(candles)
    highs = [c['high'] for c in candles]
    lows = [c['low'] for c in candles]
    closes = [c['close'] for c in candles]

    plus_dm = [0]
    minus_dm = [0]
    tr = [0]

    for i in range(1, len(candles)):
        up_move = highs[i] - highs[i-1]
        down_move = lows[i-1] - lows[i]
        plus_dm.append(up_move if up_move > down_move and up_move > 0 else 0)
        minus_dm.append(down_move if down_move > up_move and down_move > 0 else 0)
        tr.append(max(
            highs[i] - lows[i],
            abs(highs[i] - closes[i-1]),
            abs(lows[i] - closes[i-1])
        ))

    # Smoothed moving averages for +DM, -DM, TR
    def smooth(lst, period):
        smoothed = [sum(lst[:period])]
        for i in range(period, len(lst)):
            smoothed.append(smoothed[-1] - smoothed[-1]/period + lst[i])
        return smoothed

    tr_smooth = smooth(tr, period)
    plus_dm_smooth = smooth(plus_dm, period)
    minus_dm_smooth = smooth(minus_dm, period)

    plus_di = [100 * pdm/tr_ if tr_ else 0 for pdm, tr_ in zip(plus_dm_smooth, tr_smooth)]
    minus_di = [100 * mdm/tr_ if tr_ else 0 for mdm, tr_ in zip(minus_dm_smooth, tr_smooth)]
    dx = [100 * abs(p - m)/(p + m) if (p + m) else 0 for p, m in zip(plus_di, minus_di)]

    # First ADX is simple average of DX
    adx_vals = [None] * (period * 2 - 1)
    if len(dx) >= period:
        first_adx = sum(dx[:period]) / period
        adx_series = [first_adx]
        for i in range(period, len(dx)):
            adx_series.append((adx_series[-1] * (period - 1) + dx[i]) / period)
        adx_vals += adx_series
    return adx_vals[:len(candles)]

def adx_last(candles: List[Dict], period: int = 14) -> float:
    """
    Return most recent ADX value (trend strength).
    """
    adx_series_vals = adx(candles, period)
    for v in reversed(adx_series_vals):
        if v is not None:
            return v
    return 0.0

# ---------------------------------------------------------------------------
#  Swing Highs/Lows (Fractal Market Structure Detection)
# ---------------------------------------------------------------------------
def swing_highs_lows(candles: List[Dict], lookback: int = 5) -> List[Dict]:
    """
    Simple fractal-based swing high/low detection.
    Returns: list of dicts {'index': idx, 'type': 'high'/'low', 'price': price}
    """
    swings = []
    for i in range(lookback, len(candles) - lookback):
        highs = [candles[j]['high'] for j in range(i - lookback, i + lookback + 1)]
        lows = [candles[j]['low'] for j in range(i - lookback, i + lookback + 1)]
        mid = i
        if candles[mid]['high'] == max(highs):
            swings.append({'index': mid, 'type': 'high', 'price': candles[mid]['high']})
        if candles[mid]['low'] == min(lows):
            swings.append({'index': mid, 'type': 'low', 'price': candles[mid]['low']})
    return swings

# ---------------------------------------------------------------------------
#  Utility: Multi-timeframe feature builder
# ---------------------------------------------------------------------------
def multi_tf_features(
    candles_minute: List[Dict],
    candles_hour: List[Dict],
    indicators: List[str] = ["ema", "rsi", "atr"]
) -> Dict[str, float]:
    """
    Example function: combine indicators from multiple timeframes for confidence/scoring.
    """
    features = {}
    if "ema" in indicators:
        features["ema_8_min"] = ema([c["close"] for c in candles_minute], 8)
        features["ema_21_min"] = ema([c["close"] for c in candles_minute], 21)
        features["ema_21_hr"] = ema([c["close"] for c in candles_hour], 21)
    if "rsi" in indicators:
        features["rsi_min"] = rsi([c["close"] for c in candles_minute], 14)
        features["rsi_hr"] = rsi([c["close"] for c in candles_hour], 14)
    if "atr" in indicators:
        features["atr_min"] = atr_pips(candles_minute, 14)
        features["atr_hr"] = atr_pips(candles_hour, 14)
    if "adx" in indicators:
        features["adx_min"] = adx_last(candles_minute, 14)
        features["adx_hr"] = adx_last(candles_hour, 14)
    return features

# ---------------------------------------------------------------------------
#  Add more indicators or custom metrics as needed below!
#  (Bollinger Bands, MACD, custom volatility, etc.)
# ---------------------------------------------------------------------------


───────────────────────────────────────────────
📄 utils\journal.py
───────────────────────────────────────────────

# utils/journal.py
import csv
from datetime import datetime

LOG_FILE = "trade_command_pro_log.csv"

def log_trade(market,direction,sl,tp,confidence,strategy):
    with open(LOG_FILE,'a',newline='') as f:
        writer = csv.writer(f)
        writer.writerow([datetime.now(),market,direction,sl,tp,confidence,strategy])

def trade_has_closed(deal_ref):
    return True

def get_trade_details(deal_ref):
    return ("NAS100","LONG",1000.0,1010.0,50.0)

def read_daily_pnl():
    return "Daily P/L summary not implemented."



───────────────────────────────────────────────
📄 utils\news_filter.py
───────────────────────────────────────────────

# utils/news_filter.py
def is_news_halt():
    return False



───────────────────────────────────────────────
📄 utils\risk.py
───────────────────────────────────────────────

import math
from typing import Dict, Optional

from config import RISK_PCT, DEFAULT_BALANCE, MARKET_INFO, BOT_STRATEGY_PARAMS
from utils.state import get_balance
from utils.indicators import atr_pips

def size_position(
    signal: Dict,
    market: str,
    bot_name: Optional[str] = None,
    balance: Optional[float] = None,
    risk_pct: Optional[float] = None,
    min_atr_mult: float = 0.6,
    use_kelly: bool = False,
    backtest_winrate: Optional[float] = None,
    backtest_rmultiple: Optional[float] = None,
) -> Dict[str, float]:
    """
    Advanced volatility- and regime-adjusted position sizing.
    Returns dict with size, used_risk, stop_distance, and capped flag.
    """
    # Get balance (live or injected)
    balance = balance if balance is not None else (get_balance() if callable(get_balance) else DEFAULT_BALANCE)
    # Risk percent (per config, per bot override, or injected)
    if bot_name and bot_name in BOT_STRATEGY_PARAMS:
        risk_pct = BOT_STRATEGY_PARAMS[bot_name].get("risk_pct", RISK_PCT)
    else:
        risk_pct = risk_pct if risk_pct is not None else RISK_PCT

    market_info = MARKET_INFO.get(market, {})
    pip_value = market_info.get("pip_value", 1.0)
    min_size = market_info.get("min_size", 0.1)

    stop_distance = abs(signal["entry"] - signal["sl"])
    # ATR sanity check
    atr = atr_pips(market)
    min_stop = max(atr * min_atr_mult, 1e-6)
    if stop_distance < min_stop:
        stop_distance = min_stop

    # Kelly sizing (if enabled and winrate/expectancy available)
    if use_kelly and backtest_winrate and backtest_rmultiple:
        kelly = backtest_winrate - (1-backtest_winrate)/backtest_rmultiple
        kelly = max(0, min(kelly, 1))
        risk_pct = risk_pct * kelly

    risk_money = balance * risk_pct
    size = risk_money / stop_distance / pip_value  # contracts/lot size

    # Cap: do not exceed 5x mean ATR-based position
    max_size = (balance * 0.05) / (atr * pip_value) if atr else size
    size = min(size, max_size)
    size = max(size, min_size)
    size = math.floor(size / min_size) * min_size  # round down to nearest min size

    result = {
        "size": round(size, 2),
        "risk_money": round(size * stop_distance * pip_value, 2),
        "stop_distance": round(stop_distance, 4),
        "capped": size == max_size,
        "min_stop_used": stop_distance == min_stop
    }
    if result["size"] == min_size or result["capped"]:
        print(f"[INFO] Position size capped or at minimum for {market}: {result}")
    return result


───────────────────────────────────────────────
📄 utils\safe_api.py
───────────────────────────────────────────────

"""
utils/safe_api.py – Wrappers for making IG API calls safely with retries
"""

import time
from config import (
    IG_API_BASE_URL,
    IG_APP_KEY,
    IG_USERNAME,
    IG_PASSWORD,
    IG_ACCOUNT_ID,
    MARKETS
)
from utils.data import fetch_candles
from utils.session import IGSession

MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds

# Use a supported resolution for verification.
SUPPORT_RESOLUTION = "HOUR"

def safe_api_call(func, kwargs: dict, bot_name: str, context: str):
    """
    Calls `func(**kwargs)` with retry logic.
    On failure, logs and returns None.
    """
    for attempt in range(1, MAX_RETRIES + 1):
        try:
            return func(**kwargs)
        except (Exception, TypeError) as e:
            print(f"[{bot_name.upper()}][{context}] Attempt {attempt} failed: {e}")
            if attempt < MAX_RETRIES:
                time.sleep(RETRY_DELAY * attempt)
    print(f"[{bot_name.upper()}][{context}] All {MAX_RETRIES} attempts failed.")
    return None

def verify_ig_login(ig_session: IGSession = None) -> bool:
    """
    Verifies IG API credentials by attempting to fetch a candle.
    Accepts an IGSession instance (preferred), or creates/logs in a new one if not provided.
    Provides confirmation and fallback info for troubleshooting.
    """
    if ig_session is None:
        ig_session = IGSession()
        ig_session.login()
    # MARKETS is now a dict, get first epic using .values()
    test_market = list(MARKETS.values())[0]
    print(f"🔄 Checking IG API login with {test_market}...")

    result = safe_api_call(
        fetch_candles,
        kwargs={
            "session": ig_session,  # <-- corrected key for fetch_candles
            "market":    test_market,
            "timeframe": SUPPORT_RESOLUTION,
            "num":       1
        },
        bot_name="launcher",
        context="verify_login"
    )

    if result:
        print(f"✅ IG login confirmed. Candle fetched from {test_market}.")
        return True
    else:
        print(f"❌ IG login failed. No candles returned for {test_market}. Check credentials or API availability.")
        return False


───────────────────────────────────────────────
📄 utils\session.py
───────────────────────────────────────────────

import requests
from config import IG_API_BASE_URL, IG_APP_KEY, IG_USERNAME, IG_PASSWORD

class IGSession:
    """
    IGSession handles authentication and holds CST/X-SECURITY-TOKEN for all requests.
    Call IGSession.login() first and then use get_headers() for all subsequent IG API calls.
    """
    def __init__(self):
        self.session = requests.Session()
        self.cst = None
        self.security_token = None

    def login(self):
        url = f"{IG_API_BASE_URL}/session"
        headers = {
            "X-IG-API-KEY": IG_APP_KEY,
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
        payload = {
            "identifier": IG_USERNAME,
            "password": IG_PASSWORD
        }
        resp = self.session.post(url, headers=headers, json=payload, timeout=10)
        print("[IG_LOGIN] Status Code:", resp.status_code)
        print("[IG_LOGIN] Response Headers:", resp.headers)
        try:
            json_response = resp.json()
            print("[IG_LOGIN] JSON Response:", json_response)
        except Exception as e:
            print("[IG_LOGIN] No valid JSON response:", e)
            json_response = {}

        resp.raise_for_status()
        self.cst = resp.headers.get("CST")
        self.security_token = resp.headers.get("X-SECURITY-TOKEN")
        print("[IG_LOGIN] Tokens received:", {"CST": self.cst, "X-SECURITY-TOKEN": self.security_token})
        if not self.cst or not self.security_token:
            raise Exception("IG login succeeded but tokens missing in response headers")
        return self.cst, self.security_token

    def ensure_logged_in(self):
        """
        Ensures the session is logged in. If not, performs login.
        """
        if not self.cst or not self.security_token:
            self.login()

    def get_headers(self, extra_headers=None):
        """
        Returns all headers required for authenticated IG API requests.
        Optionally add/override with extra_headers dict.
        """
        if not self.cst or not self.security_token:
            raise Exception("IGSession not logged in yet!")
        headers = {
            "X-IG-API-KEY": IG_APP_KEY,
            "CST": self.cst,
            "X-SECURITY-TOKEN": self.security_token,
            "Accept": "application/json",
            "Version": "3"
        }
        if extra_headers:
            headers.update(extra_headers)
        return headers

def get_ig_session():
    """
    Returns a logged-in IGSession object for use in dashboards and bot code.
    """
    session = IGSession()
    session.ensure_logged_in()
    return session

# For quick testing
if __name__ == "__main__":
    ig = IGSession()
    ig.login()
    print("Logged in. Auth headers for subsequent requests:", ig.get_headers())


───────────────────────────────────────────────
📄 utils\session_control.py
───────────────────────────────────────────────

"""
utils/session_control.py – Centralizes session/time-window logic for trading bots.
Handles:
- 30min session bans (e.g. 08:00–08:30, 13:30–14:00 London time)
- Per-bot or per-market trading windows (e.g. 08:00–17:00 for non-scalping bots)
- Additional no-trade UTC windows (from config)
- Simple API: in_restricted_time(now, bot, market)
"""

from datetime import datetime, time as dt_time
import pytz
from config import (
    LONDON_TZ, TRADING_SESSION_1, BOTS, NO_TRADE_WINDOWS_UTC
)

# Hardcoded session bans (London time) – tuples of (start, end) hour/minute
SESSION_BANS_LONDON = [
    (dt_time(8, 0),  dt_time(8, 30)),   # 08:00–08:30
    (dt_time(13, 30), dt_time(14, 0)),  # 13:30–14:00
]

# Regular trading window (default for all non-scalping bots): 08:00–17:00 London
SESSION_DEFAULT_LONDON = (dt_time(8, 0), dt_time(17, 0))

def in_session_window_london(now_london, bot: str) -> bool:
    """
    Returns True if current time is within the allowed trading window for the bot (London time).
    """
    if bot == "scalping":
        # Scalping: only banned during hardcoded bans, otherwise 24/5
        return True
    start, end = SESSION_DEFAULT_LONDON
    return start <= now_london.time() <= end

def in_ban_windows_london(now_london) -> bool:
    """
    Returns True if current time is within any of the hardcoded London session bans.
    """
    for start, end in SESSION_BANS_LONDON:
        if start <= now_london.time() < end:
            return True
    return False

def in_no_trade_utc(now_utc) -> bool:
    """
    Returns True if current UTC hour is within a configured no-trade window.
    Example config: NO_TRADE_WINDOWS_UTC = [(21, 22)]
    """
    hour = now_utc.hour
    for start, end in NO_TRADE_WINDOWS_UTC:
        if start <= hour < end:
            return True
    return False

def in_restricted_time(bot: str = None, market: str = None, now: datetime = None) -> bool:
    """
    Returns True if trading is currently restricted for this bot/market.
    Applies all session bans, trading hours, and config no-trade windows.
    """
    now_utc = now or datetime.utcnow().replace(tzinfo=pytz.UTC)
    tz_london = pytz.timezone(LONDON_TZ)
    now_london = now_utc.astimezone(tz_london)

    # 1. Hard session ban windows (London time)
    if in_ban_windows_london(now_london):
        return True

    # 2. No-trade UTC windows (from config)
    if in_no_trade_utc(now_utc):
        return True

    # 3. Main trading session per bot (except scalping is 24/5 except for explicit bans)
    if bot:
        if not in_session_window_london(now_london, bot):
            return True

    # Add more per-market rules here if needed in the future

    return False

def can_trade(bot: str, market: str = None, now: datetime = None) -> bool:
    """
    Returns True if trading is allowed for this bot/market at this time.
    """
    return not in_restricted_time(bot, market, now)


───────────────────────────────────────────────
📄 utils\session_timer.py
───────────────────────────────────────────────

# utils/session_timer.py
from datetime import datetime
def is_trading_session():
    now = datetime.utcnow()
    total = now.hour*60 + now.minute
    return (510 <= total <= 660) or (870 <= total <= 1020)



───────────────────────────────────────────────
📄 utils\state.py
───────────────────────────────────────────────

"""
utils/state.py – Robust account, trade, and risk/drawdown state for orchestration.
Tracks and persists equity, open positions, trade counts, and session logic.
Amended 2025-06-25: Always read/write state with encoding='utf-8' to avoid 'charmap' codec errors.
If loading fails due to encoding, fall back to latin-1 and rewrite as utf-8.
"""

import threading
import json
import os
import datetime
from utils.safe_api import safe_api_call
from config import (
    STATE_DB,
    IG_API_BASE_URL,
    IG_APP_KEY,
    RISK_PCT,
    MAX_TOTAL_DAILY_DRAWDOWN_PCT,
    BOTS
)

_balance_lock = threading.Lock()
_state_lock = threading.Lock()
_last_balance = None
_equity_start = None
_max_equity = None
trade_state = {
    "open_positions": [],
    "trade_counts": {bot: 0 for bot in BOTS.keys()},
    "last_trade_time": {bot: None for bot in BOTS.keys()},
    "equity_start": None,
    "max_equity": None
}

def _load_state():
    if os.path.exists(STATE_DB):
        try:
            with open(STATE_DB, "r", encoding="utf-8") as fh:
                data = json.load(fh)
                trade_state.update(data)
        except UnicodeDecodeError as e:
            print(f"[state.py] UTF-8 decode failed: {e}. Trying latin-1 fallback.")
            try:
                with open(STATE_DB, "r", encoding="latin-1") as fh:
                    data = json.load(fh)
                    trade_state.update(data)
                # Resave as UTF-8 to repair the file going forward
                with open(STATE_DB, "w", encoding="utf-8") as f2:
                    json.dump(trade_state, f2, indent=2, default=str)
                print("[state.py] State DB re-saved as UTF-8.")
            except Exception as e2:
                print(f"[state.py] Failed to load state DB with latin-1: {e2}")
        except Exception as e:
            print(f"[state.py] Failed to load state: {e}")

def _save_state():
    # Always use encoding='utf-8' to avoid codec errors!
    with open(STATE_DB, "w", encoding="utf-8") as fh:
        json.dump(trade_state, fh, indent=2, default=str)

def get_auth_headers():
    from utils.session import CST, X_SECURITY_TOKEN
    return {
        "X-IG-API-KEY": IG_APP_KEY,
        "CST": CST,
        "X-SECURITY-TOKEN": X_SECURITY_TOKEN,
        "Accept": "application/json",
        "Content-Type": "application/json"
    }

def _fetch_account_details():
    # ... (as previously, unchanged)
    pass

def get_balance():
    global _last_balance
    data = _fetch_account_details()
    bal = None
    # ... (as previously, unchanged)
    # After getting balance:
    if bal is not None:
        with _balance_lock:
            _last_balance = bal
            # Track max equity for drawdown
            if trade_state["max_equity"] is None or bal > trade_state["max_equity"]:
                trade_state["max_equity"] = bal
                _save_state()
    return bal

def update_balance(delta):
    global _last_balance
    try:
        numeric_delta = float(delta)
    except (TypeError, ValueError) as e:
        print(f"[state.py] WARNING: update_balance called with non-numeric delta: {delta}")
        return _last_balance
    with _balance_lock:
        if _last_balance is not None:
            _last_balance = float(_last_balance) + numeric_delta
        else:
            _last_balance = numeric_delta
        # Update max equity if needed
        if trade_state["max_equity"] is None or _last_balance > trade_state["max_equity"]:
            trade_state["max_equity"] = _last_balance
            _save_state()
    return _last_balance

def check_drawdown():
    """
    Returns False if too much has been lost, True otherwise.
    Drawdown is measured from max equity since start/reset.
    """
    bal = get_balance()
    max_eq = trade_state.get("max_equity") or bal
    if max_eq and bal:
        drawdown = 1 - (bal / max_eq)
        if drawdown >= MAX_TOTAL_DAILY_DRAWDOWN_PCT / 100.0:
            print(f"[state.py] MAX DRAWDOWN breached: {drawdown*100:.2f}%")
            return False
        return True
    return True

# --- Trade orchestration state ----------------------------------------

def get_open_positions():
    with _state_lock:
        return list(trade_state["open_positions"])

def add_open_position(pos):
    with _state_lock:
        trade_state["open_positions"].append(pos)
        _save_state()

def close_position(deal_ref):
    with _state_lock:
        trade_state["open_positions"] = [
            p for p in trade_state["open_positions"] if p["deal_ref"] != deal_ref
        ]
        _save_state()

def increment_trade_count(bot, market=None):
    with _state_lock:
        if bot not in trade_state["trade_counts"]:
            trade_state["trade_counts"][bot] = 0
        trade_state["trade_counts"][bot] += 1
        _save_state()

def get_trade_count(bot):
    return trade_state["trade_counts"].get(bot, 0)

def set_last_trade_time(bot, dt=None):
    with _state_lock:
        trade_state["last_trade_time"][bot] = dt or datetime.datetime.utcnow().isoformat()
        _save_state()

def get_last_trade_time(bot):
    return trade_state["last_trade_time"].get(bot)

def reset_daily_state():
    """
    Resets daily counts, equity start, and max equity at day start.
    Should be called at UTC 00:00 or London open.
    """
    with _state_lock:
        trade_state["trade_counts"] = {bot: 0 for bot in BOTS.keys()}
        bal = get_balance()
        trade_state["equity_start"] = bal
        trade_state["max_equity"] = bal
        _save_state()

# --- Session ban logic could be here or in utils/session_control.py ---

def can_trade(bot, market, now):
    """
    Checks all limits: drawdown, daily trade count, session ban, etc.
    """
    from utils.session_control import in_restricted_time
    if not check_drawdown():
        return False
    if get_trade_count(bot) >= BOTS[bot].get("max_trades", 5):
        return False
    if in_restricted_time(now, bot, market):
        return False
    return True

# --- On module load, load last state ---
_load_state()


───────────────────────────────────────────────
📄 utils\stream_fetcher.py
───────────────────────────────────────────────

# utils/stream_fetcher.py

import threading
import time
from datetime import datetime, timedelta
from collections import deque, defaultdict

from lightstreamer.client import LightstreamerClient, Subscription

# Tick buffers and bar aggregators
_tick_buffers = defaultdict(lambda: deque())
_bar_buffers = defaultdict(lambda: defaultdict(lambda: deque(maxlen=100)))
_lock = threading.Lock()

def _on_item_update(item_update):
    epic = item_update.getItemName()
    price = float(item_update.getValue("LTP") or 0)
    ts = datetime.utcnow()
    with _lock:
        _tick_buffers[epic].append((ts, price))

def start_streaming(api_key, cst, token, epics):
    """
    Connects to IG's Lightstreamer demo endpoint, subscribes to epics,
    and starts a background thread to aggregate 5-minute bars.
    """
    client = LightstreamerClient("https://pushlightstream-demo.ig.com", "QUOTE_ADAPTER")

    # Inject IG authentication headers
    client.connectionDetails.httpExtraHeaders = {
        "X-IG-API-KEY": api_key,
        "CST": cst,
        "X-SECURITY-TOKEN": token
    }

    # Establish connection
    client.connect()

    # Subscribe to Last Traded Price (LTP) updates for each epic
    sub = Subscription("MERGE", epics, ["LTP"])
    sub.setDataAdapter("QUOTE_ADAPTER")
    sub.setRequestedSnapshot("no")
    sub.addListener(_on_item_update)
    client.subscribe(sub)

    # Launch bar aggregation thread
    threading.Thread(target=_aggregate_bars, args=(epics,), daemon=True).start()

def _aggregate_bars(epics):
    """
    Every 5 minutes, builds OHLCV bars from tick buffer.
    """
    while True:
        now = datetime.utcnow()
        next_bound = (now + timedelta(minutes=5)).replace(second=0, microsecond=0)
        time.sleep((next_bound - now).total_seconds())

        with _lock:
            for epic in epics:
                ticks = list(_tick_buffers[epic])
                _tick_buffers[epic].clear()
                if not ticks:
                    continue
                prices = [p for _, p in ticks]
                bar = {
                    "timestamp": next_bound.isoformat(),
                    "open": prices[0],
                    "high": max(prices),
                    "low": min(prices),
                    "close": prices[-1],
                    "volume": len(prices)
                }
                _bar_buffers[epic]["5MINUTE"].append(bar)

def get_stream_bars(epic, resolution):
    """
    Returns aggregated bars for the given resolution.
    Only "5MINUTE" is supported.
    """
    if resolution != "5MINUTE":
        return []
    with _lock:
        return list(_bar_buffers[epic].get("5MINUTE", []))



───────────────────────────────────────────────
📄 utils\structure.py
───────────────────────────────────────────────

# utils/structure.py

def detect_swing_breaks(candles):
    """
    Identify clean 3-candle swing breakouts/breakdowns:
    - Bullish: three rising highs then breakout above the highest.
    - Bearish: three falling lows then breakdown below the lowest.
    """
    signals = []
    for i in range(3, len(candles)):
        prev3  = candles[i-3:i]
        highs  = [c["high"] for c in prev3]
        lows   = [c["low"]  for c in prev3]
        current = candles[i]

        # Bullish swing breakout
        if highs[0] < highs[1] < highs[2] and current["close"] > highs[2]:
            signals.append({
                "direction":    "buy",
                "price":        current["close"],
                "ATR":          current["ATR"],
                "breakout":     True,
                "volume":       current["volume"],
                "avg_volume":   current["avg_volume"],
                "ema_distance": current["ema_distance"],
                "session":      current["session"]
            })

        # Bearish swing breakdown
        if lows[0] > lows[1] > lows[2] and current["close"] < lows[2]:
            signals.append({
                "direction":    "sell",
                "price":        current["close"],
                "ATR":          current["ATR"],
                "breakout":     True,
                "volume":       current["volume"],
                "avg_volume":   current["avg_volume"],
                "ema_distance": current["ema_distance"],
                "session":      current["session"]
            })

    return signals

def detect_wick_rejections(candles):
    """
    Identify high-quality wick rejections:
    - Wick length ≥ 1.5×ATR and body ≤ 0.3×ATR.
    """
    signals = []
    for c in candles:
        body = abs(c["close"] - c["open"])
        # Wick calculation depends on bar direction
        if c["close"] < c["open"]:
            wick = max(c["high"] - c["close"], c["high"] - c["open"])
        else:
            wick = max(c["open"] - c["low"], c["close"] - c["low"])
        atr = c["ATR"]

        if wick >= 1.5 * atr and body <= 0.3 * atr:
            signals.append({
                "direction":    "sell" if c["close"] < c["open"] else "buy",
                "price":        c["close"],
                "ATR":          atr,
                "wick_ratio":   wick / body if body > 0 else float("inf"),
                "body_size":    body,
                "wick_size":    wick,
                "volume":       c["volume"],
                "avg_volume":   c["avg_volume"],
                "ema_distance": c["ema_distance"],
                "trend_state":  c["trend_state"],
                "session":      c["session"]
            })

    return signals

def confirm_structure(candles, signal):
    """
    Basic market structure check:
    - For longs: last close > previous close.
    - For shorts: last close < previous close.
    """
    if len(candles) < 2:
        return True
    last_close = candles[-1]["close"]
    prev_close = candles[-2]["close"]
    if signal.get("direction") == "buy":
        return last_close > prev_close
    else:
        return last_close < prev_close



───────────────────────────────────────────────
📄 utils\test_dax.py
───────────────────────────────────────────────

from utils.execution import place_ig_order
import config

print("[LIVE MODE TEST] (Using DAX Daily Epic)")
print("DEBUG_MODE:", config.DEBUG_MODE)
print("IG_APP_KEY:", config.IG_APP_KEY)
print("IG_ACCOUNT_ID:", config.IG_ACCOUNT_ID)

epic = "IX.D.DAX.DAILY.IP"  # DAX Daily (from your IG platform link)

print(f"\nPlacing test order for {epic} ...")
result = place_ig_order(epic, "buy", 1.0, 7000, 7200)
print("Test Order Result:")
for key, value in result.items():
    print(f"  {key}: {value}")


───────────────────────────────────────────────
📄 utils\test_dax_daily_order.py
───────────────────────────────────────────────

from utils.execution import place_ig_order
import config

print("[LIVE MODE TEST] (Using DAX Daily Epic)")
print("DEBUG_MODE:", config.DEBUG_MODE)
print("IG_APP_KEY:", config.IG_APP_KEY)
print("IG_ACCOUNT_ID:", config.IG_ACCOUNT_ID)

epic = "IX.D.DAX.DAILY.IP"  # DAX Daily (from your IG platform link)

print(f"\nPlacing test order for {epic} ...")
result = place_ig_order(epic, "buy", 1.0, 7000, 7200)
print("Test Order Result:")
for key, value in result.items():
    print(f"  {key}: {value}")


───────────────────────────────────────────────
📄 utils\trade_executor.py
───────────────────────────────────────────────

import requests
import time
from config import IG_API_BASE_URL, IG_APP_KEY, IG_ACCOUNT_ID
from utils.session import IGSession

def get_live_ig_balance(ig_session: IGSession, retries=1):
    """
    Retrieves your live account's available balance from the IG /accounts endpoint.
    Uses the provided IGSession (must be logged in).
    Retries once if IG returns a 500 error.
    Returns None if any error occurs or IG returns non-JSON response.
    """
    ig_session.ensure_logged_in()  # Ensures tokens are present

    base_url = IG_API_BASE_URL.replace("/gateway/deal", "")
    url = f"{base_url}/accounts"

    headers = ig_session.get_headers({
        "Accept": "application/json"
    })

    for attempt in range(retries + 1):
        try:
            if attempt > 0:
                # Minimal log; could use logging.debug in production
                print(f"[IG BALANCE] Retry {attempt} after server error, waiting 1s...")
                time.sleep(1)
            response = ig_session.session.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            try:
                data = response.json()
            except Exception as json_err:
                print("[IG BALANCE] Could not decode JSON from /accounts:", json_err)
                return None
            accounts = data.get("accounts")
            if not accounts:
                print("[IG BALANCE] No accounts found in response:", data)
                return None
            for account in accounts:
                if account.get("accountId") == IG_ACCOUNT_ID:
                    acct_info = account.get("accountInfo", {})
                    for key in ["available", "balance"]:
                        if key in acct_info and acct_info[key] is not None:
                            return float(acct_info[key])
                    print(f"[IG BALANCE] Balance fields not found in accountInfo: {acct_info}")
                    return None
            # Fallback: return first account's balance if IG_ACCOUNT_ID not matched
            acct_info = accounts[0].get("accountInfo", {})
            for key in ["available", "balance"]:
                if key in acct_info and acct_info[key] is not None:
                    return float(acct_info[key])
            print("[IG BALANCE] Balance field not found in any accountInfo")
            return None
        except requests.exceptions.HTTPError as e:
            print(f"[IG BALANCE] HTTPError: {e} | IG: {getattr(e.response, 'text', '')}")
            if hasattr(response, "status_code") and response.status_code == 500 and attempt < retries:
                continue
            return None
        except Exception as e:
            print(f"[IG BALANCE] Exception: {e}")
            return None


───────────────────────────────────────────────
📄 utils\trailing_stop.py
───────────────────────────────────────────────

import threading
import time
from typing import Optional, Callable, Dict
from config import IG_API_BASE_URL, TRAILING_STOP_CONFIG, get_trailing_stop_config

def fetch_last_price(session, epic: str) -> Optional[float]:
    """
    Fetch the latest close price for the given epic. Returns None if fails.
    """
    try:
        resp = session.get(
            f"{IG_API_BASE_URL}/prices/{epic}/HISTORICAL/1MINUTE",
            params={"max": 1},
            timeout=10
        )
        resp.raise_for_status()
        data = resp.json().get("prices", []) or resp.json().get("candles", [])
        if not data:
            return None
        return data[-1]["close"]
    except Exception as e:
        print(f"[trailing_stop] Failed to fetch price for {epic}: {e}")
        return None

def update_stop(session, deal_ref: str, new_sl: float):
    """
    Send a stop update request for the open position.
    """
    try:
        payload = {"dealReference": deal_ref, "stopLevel": new_sl}
        resp = session.put(f"{IG_API_BASE_URL}/positions/{deal_ref}", json=payload)
        resp.raise_for_status()
    except Exception as e:
        print(f"[trailing_stop] Failed to update stop for deal {deal_ref}: {e}")

# --- Trailing Stop Strategy Pattern ------------------------------------------

class TrailingStopStrategy:
    """
    Base class for trailing stop strategies.
    """
    def __init__(self, config: dict):
        self.config = config

    def new_stop(self, last_price: float, direction: str, atr: float, initial_sl: float) -> float:
        """
        Calculate the new stop level based on trailing style.
        """
        ttype = self.config.get("type", "atr")
        if ttype == "atr":
            multiplier = self.config.get("multiplier", 1.0)
            if direction == "buy":
                return last_price - atr * multiplier
            else:
                return last_price + atr * multiplier
        elif ttype == "percent":
            pct = self.config.get("percent", 0.2)
            if direction == "buy":
                return last_price * (1 - pct / 100)
            else:
                return last_price * (1 + pct / 100)
        elif ttype == "fixed":
            points = self.config.get("fixed_points", 10)
            if direction == "buy":
                return last_price - points
            else:
                return last_price + points
        return initial_sl

def monitor_position(
    deal_ref: str,
    epic: str,
    direction: str,
    atr: float,
    initial_sl: float,
    session,
    bot_name: str = "default",
    is_open_func: Optional[Callable[[], bool]] = None,
    poll_seconds: int = 30
):
    """
    Monitors a live position and updates its stop-loss according to the trailing strategy.
    Will exit if is_open_func returns False.
    """
    sl = initial_sl
    config = get_trailing_stop_config(bot_name)
    strategy = TrailingStopStrategy(config)
    print(f"[trailing_stop] Monitoring {deal_ref}/{epic} with {config}")

    while True:
        time.sleep(poll_seconds)
        if is_open_func and not is_open_func():
            print(f"[trailing_stop] {deal_ref} closed, stopping trailing.")
            break

        last_price = fetch_last_price(session, epic)
        if last_price is None:
            continue

        new_sl = strategy.new_stop(last_price, direction, atr, sl)

        # Only trail in the favorable direction
        update = False
        if direction == "buy" and new_sl > sl:
            update = True
        elif direction == "sell" and new_sl < sl:
            update = True

        if update:
            update_stop(session, deal_ref, new_sl)
            print(f"[trailing_stop] Updated stop to {new_sl} ({direction}) for {deal_ref}")
            sl = new_sl
